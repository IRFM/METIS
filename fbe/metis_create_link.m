% METIS_CREATE_LINK: gateway between CREATE and METIS
%-------------------------------------------------------------
% fonction Matlab2013b: metis_create_link,set_default_parameters
%
% This function recieve data from CREATE (plasma LCFS, ...) ,compute METIS in mode evolution
% and return input profiles and data for CREATE equilibrium
%
% syntax: 
%
%   initialisation:       
%       [metis_data4create,internal_state] = metis_create_link([],create_data4metis,kinetic_control,parameters);
%     or
%       metis_data4create = metis_create_link([],create_data4metis,kinetic_control,parameters);
%
%   time evolution:
%       [metis_data4create,internal_state] = metis_create_link(internal_state,create_data4metis,kinetic_control,parameters);
%    or
%       metis_data4create = metis_create_link('one_time',create_data4metis,kinetic_control,parameters);
%
% input:
%
%     internal_state       = METIS internal state data structure (structure generated by the function, must not be change externally)
%     create_data4metis    = data sent from CREATE to METIS (structure)
%     kinetic_control      = optionnal structure for kinetic control (struture)
%     parameters           = configuration parameters of metis_create_link
%   
% with
%
%   internal_state content:
%
%    	internal_state.z0dstruct         =  internal data of zerodevolution
%    	internal_state.data_zerod        =  last 0d data from METIS (at one time)
%    	internal_state.profil0d          =  last 1d data from METIS (at one time)
%    	internal_state.raw_z0dinput      =  raw input from METIS simulation before change in metis_create_link
%    	internal_state.create_data4metis =  copy of last data structure from CREATE
%    	internal_state.kinetic_control   =  copy of last kinetic_control structure (can be empty)
%    	internal_state.parameters        =  parameters of metis_create_link
%    	internal_state.metis_data4create =  last data from METIS provided to CREATE
%
%   create_data4metis must contain:
%
%	create_data4metis.time	 = current time  [1] (s)
%	create_data4metis.Ip     = plasma current [1] (A)
%       create_data4metis.Bp_error_vacuum  = error magnetic field, i.e. vaccum poloidal magnetic field for breakdown computation  [1] (T)
%                                            (if = 0, brekdown model is turn off)
%
%       LCFS described by R and Z point list (vectors of same length in meter)
%  		create_data4metis.R_LCFS  [M]
%  		create_data4metis.Z_LCFS  [M]
%          with M >= 5
%
%	create_data4metis.Psi	  = poloidal flux vector Psi from magnetic axis to LCFS (Wb / 2pi, maximum value on magnetic axis) [N]
%	create_data4metis.Raxe	  = radius of magnetic axis versus PSI[n] (m)
%	create_data4metis.K	  = fux surface elongation K = (max(Z) - min(Z)) ./ (max(R) - min(R)) versus psi [N]
%          with N >= 2
% 
%   kinetic_control:
%
%       Matlab data structure in which each field design a METIS wave form or parameters
%       examples: 
%		to control NBI power waveform (1MW on first injectora and 7 MW on secon injector)
%                      kinetic_control.pnbi = 1e6 + sqrt(-1) * 7e6 
%
%               to control recycling parameter
%                      kinetic_control.Recycling = 0.97;
%
%   parameters:
%
%     parameters.ipfluxmode =   boundary condition for current diffusion equation
%                               if 0 = plasma current 
%                               if 1 = LCFS poloidal flux 
%                               if 2 = LCFS poloidal flux converted in Ip reference (stable numerical scheme to be used with FBE code)
%                               if 3 = hybrid boundary condition
%
%     parameters.metisfile  =  name of metis file that can be loaded for initilisation (optionnal, can be empty)
%
%     parameters.restart    = retsart from METIS result without initialisation if = 1, 
%                             otherwise if = 0, performs a cold restart 
%                             (recompute initial state from input data without evolution history)
%
%     default_parameters.save  =  root name of files  (one by call) used to save all internal variables on purpose of debuging
%
%     parameters.nb_pts_lcfs  =  number of points in LCFS curve
%
%
% output:
%
%      metis_data4create      = data sent from METIS to create (structure)
%      internal_state         = updated internal state (if not required as output, 
%                               will be store in persitent global data structure in appdata  Matlab stack)
%      sepa_metis            = on initialisation, if not empty, contains METIS LCFS for fist call of FBE in inverse mode
%
%  metis_data4create content:
%
%       metis_data4create.time       = current time [1] (s)
%  	metis_data4create.ip         = plasma current [1] (A)
%  	metis_data4create.li         = internal inductance (li_3) [1] 
%  	metis_data4create.betap      = beta poloidal (including fast particle contribution) [1]
%  	metis_data4create.psi        = poloidal flux profile [21] (Wb/(2pi))
%  	metis_data4create.q          = safety factor [21]
%  	metis_data4create.rho        = toroidal rho (sqrt(Phi/(pi*B0)) [21] (m)
%  	metis_data4create.phi        = toroidal flux [21] (Wb)
%  	metis_data4create.epar       = parallele electric field [21) (V/m)
%  	metis_data4create.ptot       = total pressure [21] (Pa)
%  	metis_data4created.ptotdpsi  = dPtot/dPsi  [21] (first input profile for Grad Shafranov equation)
%  	metis_data4create.fdia       = diamagnetic function(R*Bphi) [21] (T.m)
%  	metis_data4create.df2dpsi    = d(fdia^2)/dPsi [21] (second input profile for Grad Shafranov equation)
%  	metis_data4create.jphi       = surface averaged toroidal current (<J_phi/R>/<1/R>) [21] (A/m^2)
% 
%  sepa_metis content (empty if not defined):
% 		sepa_metis.Rsepa =  LCFS R coordinate
%		sepa_metis.Zsepa =  LCFS Z coordinate
%
% remarque : si cons et geo sont des structure a 1 temps, la valeur de cons.temps doit etre identique a temps.
%
% test
%      % load a metis file and
%         metis_data4create = metis_create_link
%
%      for k=1:10
%       	metis_data4create = metis_create_link('one_time')
%      end
%
% function wrote by J-F Artaud
%-----------------------------------------------------------------------
%
function [metis_data4create,internal_state,sepa_metis] = metis_create_link(internal_state,create_data4metis,kinetic_control,parameters)

% handling input
if nargin < 1
  internal_state = [];
end
if nargin < 2
  create_data4metis = [];
end
if nargin < 3
  kinetic_control = [];
end
if nargin < 3
  parameters = [];
end

% for FBE initialisation in inverse
sepa_metis = []; 

% mode without internal_state input/output
if (nargout < 2) && isempty(internal_state)
    if isappdata(0,'METIS_CREATE_INTERNAL_STATE')
	rmappdata(0,'METIS_CREATE_INTERNAL_STATE');
    end
    setappdata(0,'METIS_CREATE_INTERNAL_STATE',[]);
    internal_state = getappdata(0,'METIS_CREATE_INTERNAL_STATE');
elseif nargout < 2
    if ~isappdata(0,'METIS_CREATE_INTERNAL_STATE')
	setappdata(0,'METIS_CREATE_INTERNAL_STATE',[]);
    end
    internal_state = getappdata(0,'METIS_CREATE_INTERNAL_STATE');
elseif ischar(internal_state)
    internal_state = getappdata(0,'METIS_CREATE_INTERNAL_STATE');
else
    if isappdata(0,'METIS_CREATE_INTERNAL_STATE')
	rmappdata(0,'METIS_CREATE_INTERNAL_STATE');
    end
end

% set default parameters
if isempty(parameters) && ~isempty(internal_state) && isfield(internal_state,'parameters')
    parameters = internal_state.parameters;
end
parameters = set_default_parameters(parameters);
% switch method depending of internal state
if isempty(internal_state)
  method = 'init';
  % load metis file if is defined
  if ~isempty(parameters.metisfile)
      evalin('base','clear post');
      evalin('base',sprintf('metis_load(''%s'')',parameters.metisfile));
  end
  % test if a METIS data set is loaded in base workspace
  if evalin('base','~exist(''post'',''var'') || isempty(''post'')')
      error(sprintf('METIS file %s have not been loaded',parameters.metisfile));
  end
  memoire = [];
else
  method = 'one_time';
  z0dstruct = internal_state.z0dstruct;  
  memoire   = internal_state.memoire;
end

% retrieve METIS input data
if ~isempty(internal_state) &&  isfield(internal_state,'raw_z0dinput');
    z0dinput = internal_state.raw_z0dinput;
elseif evalin('base','~exist(''z0dinput'',''var'') || isempty(''z0dinput'')')
      error('METIS input data is not defined');
else
    z0dinput = evalin('base','z0dinput');
end


% initialise output
metis_data4create = [];
status = NaN;

% add missing field for coupling with FBE
if ~isfield(z0dinput.cons,'L_ext')
    z0dinput.cons.L_ext    = NaN * z0dinput.cons.temps;
end
if ~isfield(z0dinput.cons,'Psi_ext')
    z0dinput.cons.Psi_ext    = NaN * z0dinput.cons.temps;
end
if ~isfield(z0dinput.cons,'flux_ip')
    z0dinput.cons.flux_ip  = NaN * z0dinput.cons.temps;
end
if ~isfield(z0dinput.cons,'K_min')
    z0dinput.cons.K_min  = NaN * z0dinput.cons.temps;
end
if ~isfield(z0dinput.cons,'d0_ext')
    z0dinput.cons.d0_ext  = NaN * z0dinput.cons.temps;
end


% check data from CREATE
% create_data4metis must contain:
% * time (s)
%	create_data4metis.time	 [1]
% * plasma current (A)
%	create_data4metis.Ip	 [1]
%
% * error magnetic field, i.e. vaccum poloidal magnetic field for breakdown computation (T).
%     create_data4metis.Bp_error_vacuum  
%
% * LCFS described by R and Z point list (vectors of same length in meter)
%  		create_data4metis.R_LCFS  [m]
%  		create_data4metis.Z_LCFS  [m]
%   with m >= 5
% * poloidal flux vector Psi from magnetic axis to LCFS (Wb / 2pi, maximum value on magnetic axis)
%	create_data4metis.Psi	 [n]
% * radius of magnetic axis versus PSI (m)
%	create_data4metis.Raxe	 [n]
% * fux surface elongation K = (max(Z) - min(Z)) ./ (max(R) - min(R)) versus psi
%	create_data4metis.K	 [n]
%   with n >= 2
if isempty(create_data4metis)
    disp('INFO: CREATE data structure for METIS is empty');
end
switch method
case 'init'
     if ~isempty(create_data4metis) && isfield(create_data4metis,'time')
	  time  = create_data4metis.time(end);
	  ip_in = create_data4metis.Ip(end); 
     else
	  time  = z0dinput.cons.temps(1);
	  ip_in = z0dinput.cons.ip(1); 
     end
     disp('initialisation')
otherwise
     if ~isempty(create_data4metis) && isfield(create_data4metis,'time')
	  time  = create_data4metis.time(end);
     else
          index_t = find(z0dinput.cons.temps > (internal_state.data_zerod.temps + sqrt(eps)),1);
          if isempty(index_t)
	      time  = 2 * z0dinput.cons.temps(end) - z0dinput.cons.temps(end - 1);                 
          else
	      time  = z0dinput.cons.temps(index_t);
          end
     end
     if ~isempty(create_data4metis) && isfield(create_data4metis,'time')
	  ip_in = create_data4metis.Ip(end); 
     else
           index_ip = find(z0dinput.cons.temps >= time,1);
           if isempty(index_ip)
 	      ip_in = z0dinput.cons.ip(end);        
           else
	      ip_in = z0dinput.cons.ip(index_ip);
	   end
     end
end
% synchronise METIS input and CREATE
index = find(z0dinput.cons.temps >= time,1);
if isempty(index)
  index = length(z0dinput.cons.temps);
end

% handle LCFS from CREATE
if isfield(create_data4metis,'R_LCFS') && isfield(create_data4metis,'Z_LCFS')
    R0  = (min(create_data4metis.R_LCFS) + max(create_data4metis.R_LCFS)) ./ 2;
    z0 = (min(create_data4metis.Z_LCFS) + max(create_data4metis.Z_LCFS)) ./ 2;
    %
    KH = sort(unique(convhull(create_data4metis.R_LCFS,create_data4metis.Z_LCFS)));
    if (length(KH) ~= length(create_data4metis.R_LCFS))
        index_full = 1:length(create_data4metis.R_LCFS);
        Rsepa = create_data4metis.R_LCFS(KH);
        Zsepa = create_data4metis.Z_LCFS(KH);
        create_data4metis.R_LCFS = interp1(KH,Rsepa,index_full,'linear');
        create_data4metis.Z_LCFS = interp1(KH,Zsepa,index_full,'linear');
        indbad_lcfs = find(~isfinite(create_data4metis.R_LCFS) | ~isfinite(create_data4metis.Z_LCFS));
        if ~isempty(indbad_lcfs)
            create_data4metis.R_LCFS(indbad_lcfs) = [];
            create_data4metis.Z_LCFS(indbad_lcfs) = [];
        end
    end
    geo_metis    = zerod_get1t(z0dinput.geo,index);
    if isfield(create_data4metis,'Raxe')
        loc.d0 = create_data4metis.Raxe(1) - create_data4metis.Raxe(end);
    else
	loc.d0 = 0;
    end
    rb0          = geo_metis.R .* geo_metis.b0;
    if length(create_data4metis.R_LCFS) ~= parameters.nb_pts_lcfs
	[Rsepa_out,Zsepa_out] = z0reshape_sepa(geo_metis,loc,create_data4metis.R_LCFS,create_data4metis.Z_LCFS - (min(create_data4metis.Z_LCFS) + max(create_data4metis.Z_LCFS)) ./ 2,5,1,parameters.nb_pts_lcfs);
        Zsepa_out = Zsepa_out - (min(Zsepa_out) + max(Zsepa_out)) / 2;
    else
	Rsepa_out = create_data4metis.R_LCFS;
	Zsepa_out = create_data4metis.Z_LCFS;
    end
    [vps,sps,sexts,peris,geo_metis,void_xpoint,sepa_metis.Rsepa,sepa_metis.Zsepa] =  ...
        zgeo0(geo_metis,Rsepa_out,Zsepa_out,1);
    sepa_metis.Zsepa = sepa_metis.Zsepa -  (min(sepa_metis.Zsepa) + max(sepa_metis.Zsepa)) / 2;   
    %
    geo_metis.z0 = z0;
    geo_metis.R  = R0;
    geo_metis.b0 = rb0 ./geo_metis.R;
    %figure;plot(create_data4metis.R_LCFS,create_data4metis.Z_LCFS,'.r',Rsepa_out,Zsepa_out + geo_metis.z0,'-.b',sepa_metis.Rsepa,sepa_metis.Zsepa + geo_metis.z0,'k');
else
    geo_metis    = zerod_get1t(z0dinput.geo,index);
    [vps,sps,sexts,peris] =  zgeo0(geo_metis);
end
%  if isfield(create_data4metis,'R_LCFS') && isfield(create_data4metis,'Z_LCFS')
%  KH = sort(unique(convhull(create_data4metis.R_LCFS,create_data4metis.Z_LCFS)));
%      if (length(KH) ~= length(create_data4metis.R_LCFS))
%  	index_full = 1:length(create_data4metis.R_LCFS);
%  	Rsepa = create_data4metis.R_LCFS(KH);
%  	Zsepa = create_data4metis.Z_LCFS(KH);
%  	create_data4metis.R_LCFS = interp1(KH,Rsepa,index_full,'linear');
%  	create_data4metis.Z_LCFS = interp1(KH,Zsepa,index_full,'linear');
%  	indbad_lcfs = find(~isfinite(create_data4metis.R_LCFS) | ~isfinite(create_data4metis.Z_LCFS));
%  	if ~isempty(indbad_lcfs)
%  	    create_data4metis.R_LCFS(indbad_lcfs) = [];
%  	    create_data4metis.Z_LCFS(indbad_lcfs) = [];
%  	end
%      end
%      geo_metis    = zerod_get1t(z0dinput.geo,index);
%      rb0          = geo_metis.R .* geo_metis.b0;
%      geo_metis.R  = (min(create_data4metis.R_LCFS) + max(create_data4metis.R_LCFS)) ./ 2;
%      geo_metis.b0 = rb0 ./geo_metis.R;
%      geo_metis.z0 = (min(create_data4metis.Z_LCFS) + max(create_data4metis.Z_LCFS)) ./ 2;
%      [vps_next,void_sps,void_sexts,void_peris,geo_metis,void_xpoint,sepa_metis.Rsepa,sepa_metis.Zsepa] =  ...
%  	zgeo0(geo_metis,create_data4metis.R_LCFS,create_data4metis.Z_LCFS - geo_metis.z0,1);
%  else
%      geo_metis    = zerod_get1t(z0dinput.geo,index);
%  end
% get other metis input data
% securite
if isfield(z0dinput.exp0d,'Rsepa') && isempty(z0dinput.exp0d.Rsepa)
	z0dinput.exp0d = rmfield(z0dinput.exp0d,'Rsepa');
	z0dinput.exp0d = rmfield(z0dinput.exp0d,'Zsepa');
end
if isfield(z0dinput.exp0d,'XDURx') && isempty(z0dinput.exp0d.XDURx)
	z0dinput.exp0d = rmfield(z0dinput.exp0d,'XDURx');
	z0dinput.exp0d = rmfield(z0dinput.exp0d,'XDURt');
	z0dinput.exp0d = rmfield(z0dinput.exp0d,'XDURv');
end
% initialisation
cons1t  = zerod_get1t(z0dinput.cons,index);
exp0d1t = zerod_get1t(z0dinput.exp0d,index);
% set LCFS 
switch method
    case 'init'        
	if parameters.restart == 1
	    % LCFS can't be changed    
	    geo_metis    = zerod_get1t(z0dinput.geo,index);
            [vps,sps,sexts,peris] =  zgeo0(geo_metis);
	    if isfield(exp0d1t,'Rsepa') && ~isempty(exp0d1t.Rsepa)
		sepa_metis.Rsepa = exp0d1t.Rsepa;
		sepa_metis.Zsepa = exp0d1t.Zsepa + geo_metis.z0;
            else 
		[vps_next,void_sps,void_sexts,void_peris,geo_metis,void_xpoint,sepa_metis.Rsepa,sepa_metis.Zsepa] =  ...
		    zgeo0(geo_metis,[],[],1);  
		sepa_metis.Zsepa = sepa_metis.Zsepa  + geo_metis.z0;  
	    end
	elseif isfield(create_data4metis,'R_LCFS') && isfield(create_data4metis,'Z_LCFS')
	  exp0d1t.Rsepa = sepa_metis.Rsepa;
	  exp0d1t.Zsepa = sepa_metis.Zsepa;
        end
    otherwise
      if isfield(create_data4metis,'R_LCFS') && isfield(create_data4metis,'Z_LCFS')
	  exp0d1t.Rsepa = sepa_metis.Rsepa;
	  exp0d1t.Zsepa = sepa_metis.Zsepa;
      end
end
%  if isfield(create_data4metis,'R_LCFS') && isfield(create_data4metis,'Z_LCFS')
%      exp0d1t.Rsepa = sepa_metis.Rsepa;
%      exp0d1t.Zsepa = sepa_metis.Zsepa;
%  end
% METIS internal parameters
option = z0dinput.option;

% replace z0dinput METIS data with kinetic control prescribe data
% parametre des options de Metis
if ~isempty(kinetic_control)
        cons_names   = fieldnames(cons1t);
        option_names = fieldnames(cons1t);
	names= fieldnames(kinetic_control);
        % boucel sur les options
	for k=1:length(input_option)
		indm = strmatch(names{k},cons_names,'exact');
		if length(indm) > 1
		    error(sprintf('miss defined kinetic_control fieldnames (%s)',names{k}));
		elseif ~isempty(indm)
		    cons1t.(names{k}) = kinetic_control.(names{k})(end);
		else 
		    indm = strmatch(names{k},option_names,'exact');
		    if length(indm) > 1
			  error(sprintf('miss defined kinetic_control fieldnames (%s)',names{k}));
		    elseif ~isempty(indm)
			  option.(names{k}) = kinetic_control.(names{k});
		    else 		
			error(sprintf('undefined input %s in Metis input',names{k}));	
		    end
		end
	end
end
% calcul de Lp
mu0 = 4 .* pi .* 1e-7;
if ~isempty(internal_state) && isfield(internal_state,'z0dstruct')
  li  = interp1(internal_state.z0dstruct.zs.temps,internal_state.z0dstruct.zs.li,time,'nearest','extrap');
else
  li  = 1;
end
Lp  =  mu0 * geo_metis.R .* (log(8 *  geo_metis.R ./ ((sps/pi).^0.5)) - 2 + li ./ 2);

% on init set poloidal flux offset
switch method
case 'init'
    if ~isempty(create_data4metis) && isfield(create_data4metis,'Psi')
	internal_state.psi_offset = create_data4metis.Psi(end);
    else
 	internal_state.psi_offset = 0;   
    end
    ip_star  = ip_in;
otherwise
    %norme_psi = internal_state.profil0d.psi(1) - internal_state.profil0d.psi(end);
    if ~isempty(create_data4metis) && isfield(create_data4metis,'Psi')   
	%ip_star   = internal_state.data_zerod.ip .* (1 + tanh((internal_state.profil0d.psi(end) - (create_data4metis.Psi(end) - internal_state.psi_offset)) ./ norme_psi));
	norme_psi = Lp ./ 2 ./ pi .* internal_state.data_zerod.ip;
	ip_star   = internal_state.data_zerod.ip .* (1 + tanh((internal_state.profil0d.psi(end) - (create_data4metis.Psi(end) - internal_state.psi_offset)) ./ norme_psi));
	fprintf('Psi: ');disp([internal_state.profil0d.psi(1),internal_state.profil0d.psi(end),create_data4metis.Psi(1) - internal_state.psi_offset,create_data4metis.Psi(end) - internal_state.psi_offset]);
	fprintf('Ip: ');disp([internal_state.data_zerod.ip,ip_star]);
    else
	ip_star  = ip_in;   
    end
end
% replace z0dinput METIS data with CREATE prescribe data
cons1t.temps = time;
exp0d1t.temps = time;

%
switch parameters.ipfluxmode
case 0
    % 0 = plasma current provided
    cons1t.ip = ip_in;
    option.vloop = 0;

case 1
    % 1 = LCFS poloidal flux provided
    cons1t.ip = ip_in;
    option.vloop = 4;

case 2
    % 2 = LCFS poloidal flux provided converted in Ip reference (Ip*)
    cons1t.ip = ip_star;
    option.vloop = 0;

case 3
    % 3 = hybride CL.
    if ~isempty(internal_state)
	cons1t.ip = internal_state.data_zerod.ip;
    else
	cons1t.ip = ip_in;
    end
    option.vloop = 5;
end
% edge poloidal flux   
if isfield(create_data4metis,'Psi')
    cons1t.flux = create_data4metis.Psi(end) - internal_state.psi_offset;
    if isfield(create_data4metis,'L_ext')
        cons1t.L_ext    = create_data4metis.L_ext;
    else
        cons1t.L_ext    = Lp/2/pi;
    end
    if isfield(create_data4metis,'Psi_ext')
        cons1t.Psi_ext    = create_data4metis.Psi_ext;
    else
        cons1t.Psi_ext    =  NaN;
    end
    cons1t.flux_ip  = cons1t.flux -  cons1t.L_ext .* cons1t.ip;
    % external flux variation is missing
    % from cronos
    %datakp1.cons.flux_ip = datakp1.equi.free.psi_ext - datak.equi.free.psi_ext - datak.equi.free.L_ext .* datak.equi.ip + datak.equi.psi(end);
    if ~isempty(internal_state)
        if isfield(internal_state,'z0dstruct') && isfield(internal_state.z0dstruct.z0dinput.cons,'Psi_ext')
            indm1 = find(internal_state.z0dstruct.z0dinput.cons.temps >= time,1);
            if isempty(indm1)
                indm1 = length(internal_state.z0dstruct.z0dinput.cons.temps) - 1;
            else
                indm1 = indm1 - 1;
            end
            if indm1 > 0
                Psi_ext_m1 = internal_state.z0dstruct.z0dinput.cons.Psi_ext(indm1);
                if isfinite(Psi_ext_m1) && isfinite(cons1t.Psi_ext)
                    cons1t.flux_ip  = cons1t.flux_ip  + cons1t.Psi_ext - Psi_ext_m1;
                end
            end
        end
    end
    
end
% error field for breakdown, if it is provided by CREATE
if isfield(create_data4metis,'Bp_error_vacuum')
    option.berror = create_data4metis.Bp_error_vacuum;
end 
% adding constraint on K_min, if it is provided by CREATE
if isfield(create_data4metis,'K')
    cons1t.K_min  = min(create_data4metis.K);
end
% adding contraint on Shafranov shift at magnetic axis, if it is provided by CREATE
if isfield(create_data4metis,'Raxe')
    cons1t.d0_ext = create_data4metis.Raxe(1) - create_data4metis.Raxe(end);
end

% call of METIS
fprintf('time = %g \n',time);
switch method
case 'init'
    if parameters.restart == 1
	[z0dstruct,z0dinput_void,zs,profil] = metis2z0dstruct(evalin('base','post'),time);
	if isfield(z0dinput.exp0d,'Rsepa') && ~isempty(z0dinput.exp0d.Rsepa)
	    [z0dstruct.z0dinput.exp0d.Rsepa,z0dstruct.z0dinput.exp0d.Zsepa] = ...
		resample_LCFS(z0dinput.geo,z0dinput.exp0d.Rsepa,z0dinput.exp0d.Zsepa,parameters.nb_pts_lcfs);
	    z0dinput.exp0d.Rsepa = z0dstruct.z0dinput.exp0d.Rsepa;
	    z0dinput.exp0d.Zsepa = z0dstruct.z0dinput.exp0d.Zsepa;
	    exp0d1t = zerod_get1t(z0dinput.exp0d,index);
	    exp0d1t.temps = time;
	end
	[zs,profil,z0dstruct] = zerodevolution(z0dstruct,option,time,cons1t,geo_metis,[],exp0d1t,exp0d1t);
    else
	if isfield(z0dinput.exp0d,'Rsepa') && ~isempty(z0dinput.exp0d.Rsepa)
	    [z0dstruct.z0dinput.exp0d.Rsepa,z0dstruct.z0dinput.exp0d.Zsepa] = ...
		resample_LCFS(z0dinput.geo,z0dinput.exp0d.Rsepa,z0dinput.exp0d.Zsepa,parameters.nb_pts_lcfs);
	    z0dinput.exp0d.Rsepa = z0dstruct.z0dinput.exp0d.Rsepa;
	    z0dinput.exp0d.Zsepa = z0dstruct.z0dinput.exp0d.Zsepa;
	    exp0d1t = zerod_get1t(z0dinput.exp0d,index);
	    exp0d1t.temps = time;
	end
	[zs,profil,z0dstruct] = zerodevolution([],option,time,cons1t,geo_metis,[],exp0d1t,exp0d1t);
    end
    % add missing field for coupling with FBE
    if ~isfield(z0dstruct.z0dinput.cons,'L_ext')
	    if isfield(create_data4metis,'L_ext')
		z0dstruct.z0dinput.cons.L_ext    = create_data4metis.L_ext * ones(size(z0dstruct.z0dinput.cons.temps));
	    else
		z0dstruct.z0dinput.cons.L_ext    = Lp/2/pi * ones(size(z0dstruct.z0dinput.cons.temps));
	    end
    end
    if ~isfield(z0dstruct.z0dinput.cons,'Psi_ext')
	    if isfield(create_data4metis,'Psi_ext')
		z0dstruct.z0dinput.cons.Psi_ext    = create_data4metis.Psi_ext * ones(size(z0dstruct.z0dinput.cons.temps));
	    else
		z0dstruct.z0dinput.cons.Psi_ext    = NaN * ones(size(z0dstruct.z0dinput.cons.temps));
	    end
    end
   if ~isfield(z0dstruct.z0dinput.cons,'flux_ip')
	z0dstruct.z0dinput.cons.flux_ip  = z0dstruct.zs.edgeflux/2/pi - z0dstruct.z0dinput.cons.L_ext .* z0dstruct.z0dinput.cons.ip;
    end
    if ~isfield(z0dstruct.z0dinput.cons,'K_min')
	z0dstruct.z0dinput.cons.K_min  = ones(size(z0dstruct.z0dinput.cons.temps));
    end
    if ~isfield(z0dstruct.z0dinput.cons,'d0_ext')
	z0dstruct.z0dinput.cons.d0_ext  = z0dstruct.zs.d0;
    end
case 'one_time'
    [zs,profil,z0dstruct] = zerodevolution(z0dstruct,option,time,cons1t,geo_metis,[],exp0d1t,exp0d1t);
otherwise
    error(sprintf('undefined method %s',method));
end

% generate output for CREATE 
metis_data4create.time       = zs.temps;
metis_data4create.ip         = zs.ip;
metis_data4create.li         = zs.li;
metis_data4create.betap      = zs.betaptot;
metis_data4create.w          = zs.w;
metis_data4create.xli        = profil.xli;
metis_data4create.psi        = profil.psi;
metis_data4create.q          = profil.qjli;
metis_data4create.rho        = profil.rmx;
metis_data4create.phi        = profil.phi;
metis_data4create.epar       = profil.epar;
metis_data4create.ptot       = profil.ptot;
metis_data4create.dptotdpsi  = profil.dptotdpsi;
metis_data4create.fdia       = profil.fdia;
metis_data4create.df2dpsi    = profil.df2dpsi;
metis_data4create.jphi       = profil.jli;
metis_data4create.jphi       = profil.jli;
metis_data4create.surface    = cumtrapz(profil.xli,profil.spr,2);
metis_data4create.volume     = cumtrapz(profil.xli,profil.vpr,2);
metis_data4create.rmx        = profil.rmx;
metis_data4create.C2         = profil.C2;
metis_data4create.Raxe       = profil.Raxe;
metis_data4create.ri         = profil.ri;
metis_data4create.r2i        = profil.r2i;
metis_data4create.psin       = (metis_data4create.psi - metis_data4create.psi(:,1) * ones(1,size(metis_data4create.psi,2))) ./ ...
                              ((metis_data4create.psi(:,end) - metis_data4create.psi(:,1)) * ones(1,size(metis_data4create.psi,2)));

% alternative derivation of dPtotdPsi and df2dpsi
% improved value on magnetic axis
psid1             = pdederive(profil.xli,metis_data4create.psi,0,2,2,1);
psid1(:,end)      = -(2*pi) .* mu0 .* metis_data4create.rmx(:,end) .* metis_data4create.ip ./ metis_data4create.C2(:,end);
% dspidx = 0 au centre et d2psidx2 doit etre nul au bord pour que ip soit defini precisement
psid2    = pdederive(profil.xli,metis_data4create.psi,1,0,2,2);
dpdpsi   = pdederive(profil.xli,metis_data4create.ptot,0,1,2,1) ./ min(-eps,psid1);
dpdpsi(psid1 > -eps) = 0;
dpdpsi(:,1) = max(0,dpdpsi(:,1)); 
% estimation simple de la valeur sur l'axe : (dP/dpsi ~= 0 sur l'axe meme si dP/drho = 0)
% peu d'incidence sur l'integrale
dpdx_1 = (metis_data4create.ptot(:,2) - metis_data4create.ptot(:,1)) ./ profil.xli(2) .^ 2;
dpdpsi_1 = - 2 .* dpdx_1 ./ (metis_data4create.fdia(:,1) ./ metis_data4create.Raxe(:,1)) .* metis_data4create.q(:,1) ./ metis_data4create.rmx(:,end) .^ 2;
dpdpsi(:,1) = max(dpdpsi(:,1),dpdpsi_1);
df2dpsi  = 2 .* mu0 .* (max(0,metis_data4create.jphi) .* metis_data4create.ri - dpdpsi)./ metis_data4create.r2i;
% direct derivation
for k=1:size(metis_data4create.psi,1)
    dpdpsi_direct(k,:) =   pdederive(metis_data4create.psi(k,:),metis_data4create.ptot(k,:),2,2,2,1);
    df2dpsi_direct(k,:) =   pdederive(metis_data4create.psi(k,:),metis_data4create.fdia(k,:) .^ 2,2,2,2,1);
end
jphi_rebuilt = (df2dpsi .* metis_data4create.r2i ./ (2 .* mu0)  + dpdpsi) ./ metis_data4create.ri;
if nargin <= 1   
    figure;
    subplot(2,2,1)
    plot(metis_data4create.psin',metis_data4create.dptotdpsi','r',metis_data4create.psin',dpdpsi','b',metis_data4create.psin',dpdpsi_direct','g');
    xlabel('\psi_n');
    ylabel('dPd\psi');
    title('red = METIS; blue = For create; green =Direct');
    hold on
    plot(metis_data4create.psin',metis_data4create.dptotdpsi','.r',metis_data4create.psin',dpdpsi','.b',metis_data4create.psin',dpdpsi_direct','.g');
    subplot(2,2,2)
    plot(metis_data4create.psin',metis_data4create.df2dpsi','r',metis_data4create.psin',df2dpsi','b',metis_data4create.psin',df2dpsi_direct','g');
    xlabel('\psi_n');
    ylabel('dF^2d\psi');
    hold on
    plot(metis_data4create.psin',metis_data4create.df2dpsi','.r',metis_data4create.psin',df2dpsi','.b',metis_data4create.psin',df2dpsi_direct','.g');
    subplot(2,2,3);
    plot(metis_data4create.psin',metis_data4create.jphi','r',metis_data4create.psin',jphi_rebuilt','b');
    xlabel('\psi_n');
    ylabel('J_\phi');
    hold on
    plot(metis_data4create.psin',metis_data4create.jphi','.r',metis_data4create.psin',jphi_rebuilt','.b');
    
    drawnow
end
metis_data4create.dptotdpsi = dpdpsi;
metis_data4create.df2dpsi   = df2dpsi;



% generate internal state
internal_state.z0dstruct         = z0dstruct;
internal_state.data_zerod        = zs;
internal_state.profil0d          = profil;
internal_state.raw_z0dinput      = z0dinput;
internal_state.create_data4metis = create_data4metis;
internal_state.kinetic_control   = kinetic_control;
internal_state.parameters        = parameters;
internal_state.metis_data4create = metis_data4create;


if ~isfield(memoire,'time')
  memoire.time      = time;
  memoire.Lp        = Lp;
else
  memoire.time             = union(memoire.time,time);
  index                    = find(memoire.time == time,1);
  memoire.Lp(index)        = Lp;
end
% figure(82);clf
% plot(memoire.time,memoire.Lp,'b',z0dstruct.z0dinput.cons.temps,z0dstruct.z0dinput.cons.L_ext,'r');
% try
%     rap = mean(memoire.Lp) ./ mean(z0dstruct.z0dinput.cons.L_ext)
% end
% set(gca,'xlim',[604,Inf]);
% drawnow

internal_state.memoire    = memoire;
%
logtrace.time = time;
logtrace.option = option;
logtrace.cons1t = cons1t;
logtrace.geo_metis = geo_metis;
logtrace.exp0d1t   = exp0d1t;            
logtrace.psi_axe_diff   = internal_state.profil0d.psi(1);
logtrace.psi_lcfs_diff  = internal_state.profil0d.psi(end);
if ~isempty(create_data4metis) && isfield(create_data4metis,'Psi')
    logtrace.psi_axe_eq     = create_data4metis.Psi(1) - internal_state.psi_offset;
    logtrace.psi_lcfs_eq    = create_data4metis.Psi(end) - internal_state.psi_offset;
else
     logtrace.psi_axe_eq    = NaN;
    logtrace.psi_lcfs_eq    = NaN;   
end
logtrace.ip0d           = internal_state.data_zerod.ip;
logtrace.ip_star        = ip_star;

if isfield(internal_state,'log')
    internal_state.log{end+1} = logtrace;
else
    internal_state.log = {logtrace};
end

% mode without internal_state input/output
if nargout < 2
    setappdata(0,'METIS_CREATE_INTERNAL_STATE',internal_state);
end

% save results if request
if ~isempty(parameters.save)
    save(sprintf('%s_%d',parameters.save,index));
end

% set default parameters
function parameters = set_default_parameters(parameters)

% ipfluxmode: boundary condition for current diffusion equation
% 0 = plasma current provided
% 1 = LCFS poloidal flux provided
% 2 = LCFS poloidal flux provided converted in Ip reference (Ip*)
default_parameters.ipfluxmode = 0;
min_parameters.ipfluxmode = 0;
max_parameters.ipfluxmode = 2;

% metisfile: name of metis file taht can be loaded during initilistion (optionnal, can be empty)
default_parameters.metisfile = '';

% restart from METIS result without initialisation if = 1
default_parameters.restart = 0;
min_parameters.restart = 0;
max_parameters.restart = 1;

% debug mode
% provide root name of files where all restuls are save (one by call)
default_parameters.save  = '';

% number of points in LCFS curve
default_parameters.nb_pts_lcfs = 301;
min_parameters.nb_pts_lcfs = 31;
max_parameters.nb_pts_lcfs = 1001;

% maximum abs(dIp/dt) (A/s)
default_parameters.max_abs_dip_dt  = 1e7;
min_parameters.max_abs_dip_dt = 1e5;
max_parameters.max_abs_dip_dt = 1e8;

if isempty(parameters)

  parameters = default_parameters; 

else
  
    noms = fieldnames(default_parameters);
    for k = 1:length(noms)
	if ~isfield(parameters,noms{k})
	    parameters.(noms{k}) = default_parameters.(noms{k});
	elseif isnumeric(parameters.(noms{k})) && ((parameters.(noms{k}) < min_parameters.(noms{k})) ||  (parameters.(noms{k}) < min_parameters.(noms{k})))
	    error(sprintf('Parameter %s range must between %g and %g',noms{k},min_parameters.(noms{k}),min_parameters.(noms{k})));
	end
    end

end

function [Rsepa_out,Zsepa_out] = resample_LCFS(geo,Rsepa_in,Zsepa_in,nbpts)

% centre
R0  = (min(Rsepa_in,[],2) + max(Rsepa_in,[],2)) ./ 2;
Z0  = (min(Zsepa_in,[],2) + max(Zsepa_in,[],2)) ./ 2;

%out
Rsepa_out = NaN * ones(size(Rsepa_in,1),nbpts);
Zsepa_out = NaN * ones(size(Zsepa_in,1),nbpts);

% loop on time
for k=1:size(Rsepa_in,1)
    R = Rsepa_in(k,:);
    Z = Zsepa_in(k,:);
    %
    KH = sort(unique(convhull(R,Z)));
    if (length(KH) ~= length(R))
        index_full = 1:length(R);
        Rsepa = R(KH);
        Zsepa = Z(KH);
        R_LCFS = interp1(KH,Rsepa,index_full,'linear');
        Z_LCFS = interp1(KH,Zsepa,index_full,'linear');
        indbad_lcfs = find(~isfinite(R_LCFS) | ~isfinite(Z_LCFS));
        if ~isempty(indbad_lcfs)
            R_LCFS(indbad_lcfs) = [];
            Z_LCFS(indbad_lcfs) = [];
        end
    else
        R_LCFS=R;
        Z_LCFS=Z;
    end
    loc.d0 = 0;
    geo_metis    = zerod_get1t(geo,k);
    [Rs,Zs] = z0reshape_sepa(geo_metis,loc,R_LCFS,Z_LCFS - (min(Z_LCFS) + max(Z_LCFS)) ./ 2,5,1,nbpts);
    Rsepa_out(k,:) = Rs - (min(Rs) + max(Rs)) / 2 + R0(k); 
    Zsepa_out(k,:) = Zs - (min(Zs) + max(Zs)) / 2 + Z0(k); 
    %figure(21);clf;plot(R,Z,'.r',Rsepa_out(k,:),Zsepa_out(k,:),'-.b');drawnow
end   


