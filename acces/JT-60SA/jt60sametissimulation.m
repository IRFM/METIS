% JT60SAMETISSIMULATION : prototype of scenarion generator for JT-60SA
%-----------------------------------------------------------------------------------------------------------
% function Matlab 2012b: jt60sametissimulation.m -> jt60sametissimulation
%
% This function prototype of scenarion generator for JT-60SA
%
% syntax:
%
%   testing :
%       z0dinput = jt60sametissimulation([],'',[]);
%
%   parameters declaration:
%       option = jt60sametissimulation(1);
%
%   computation :
%       [z0dinput,tsnapshot] = jt60sametissimulation(sepa_option,parameters_filename,reference_simulation);
%
% input:
%
%     sepa_option: etheir scenario label, CREATE reference or data structure for LCFS description (see below)
%                  labels in {1,2,3,4.1,4.2,5.1,5.2}
%
%     parameters_filename: name of METIS parametrs file or METIS paramters data structure (see metis4itm.m and zerod_param.m)
%                          leave empty to use default parameters
%
%     reference_simulation: Input data for scenario
%
% structure details for reference_simulation (with data example for dummu JT-60SA scenario):
%
%      reference_simulation.gas = 2;                         % gas species as in METIS (1=H, 2=D, 3=DT & 4=He)          
%      reference_simulation.ip = 5.5e6;                      % plasma current (A)
%      reference_simulation.rb0 =  2.25.* 2.94 ;             % magnetic rigidity (T.m)
%      reference_simulation.voltage_first = 'high';          % burn through vloop high/low
%      reference_simulation.flux =  'full';                  % Available flux from pre-magnetisation (half/full).
%      reference_simulation.f_Greenwald = 0;                 % density Greenwald fraction for the flattop, set to 0 if density is prescibe
%      reference_simulation.density     = 6e19;              % electron density during flattop, to be setted if f_Greenwald = 0 (m^-3) 
%      reference_simulation.edge_density_factor = 1;         % factor applied to edge density scaling law
%      reference_simulation.H_H = 1;                         % enhancement for the selected scaling law during H-mode phase
%      reference_simulation.ITB = 'on';                      % allows or not ITB formation (on/off)
%      reference_simulation.shot = 1;                        % shot number (used as reference number in UAL ITM or IMAS)
%      reference_simulation.run  = 1;                        % run  number (for UAL wrinting)
%      reference_simulation.PNBI_N = 11.3e6;                 % maximum power for NNBI (W)
%      reference_simulation.PNBI_P = 24e6;                   % maximum power for PNBI (W)
%      reference_simulation.PICRH = 0e6;                     % maximum power on alternative ICRH/NBI source (W)
%      reference_simulation.PECCD    = 7e6;                  % maximum power for ECCD (W)
%      reference_simulation.PBREAK   = 1e6;                  % maximum power for ECRH during breakdown (W)
%      reference_simulation.PRAMPUP  = 7e6;                  % power applied during ramp-up varied with density  and plasma current (max power at the end of ramp-up)
%      reference_simulation.Recycling = 0.97;                % Recycling coefficient
%      reference_simulation.radiation  = 'Lz';               % model for line radiative power in core plasam (Lz = colling rate or Matthews)
%      reference_simulation.SOL_model  = '2_points';         % SOL model: scaling or 2_points
%      reference_simulation.runaway  = 'ON';                 % turn on or off runaway model
%      reference_simulation.breakdown  = 'ON';               % turn on or off breakdown model
%      reference_simulation.duration         = 30;           % shot duration including ramp-up and flat-top but without ramp-down (s)
%      reference_simulation.sepa_create      = 'No';         % Plasma shape: if = Yes, use LCFS provided by CREATE team (available for scenario 2); if = No, use LCFS generated by the program
%      reference_simulation.f_dipdt_rampup     = 1;          % Ramp-up rate: multiplication factor applied to dIp/dt for plasma current ramp-up with respect  to reference case:\nH. Urano et al, Fusion Engineering and Design 100 (2015) 345-356
%      reference_simulation.f_dipdt_rampdown     = 1;        % Ramp-down rate: multiplication factor applied to dIp/dt for plasma current ramp-down with respect  to reference case:\nH. Urano et al, Fusion Engineering and Design 100 (2015) 345-356
%      reference_simulation.fte_edge = 1;                    % Multiplication factor applied to LCFS temperature (for studies of egde radiation and poloidal flux comsumption);\n Allows to choose between cold edge and ho edge plasma.\nInfluence ramp-up
%      reference_simulation.size_decrease_rampdown = 1;      %
%  
%
% structure details for sepa_option (with data example for ITER):
%
%      sepa_option.rxup      = 0.466;     % upper triangularity (minor radius unit)
%      sepa_option.zxup      = 1.687;     % upper altitude X point (minor radius unit)
%      sepa_option.apup      = 0;         % upper separatrix angle (R,X)  (LFS, degrees)
%      sepa_option.amup      = 0;         % upper separatrix angle (-R,X) (HFS, degrees)
%      sepa_option.ra        = 6.2;       % major radius R0 (m) [6.2]
%      sepa_option.za        = 0;         % altitude of the magnetic axis (m) [0.9]
%      sepa_option.a         = 2;         % minor radius (m) [2]
%      sepa_option.rxdo      = 0.568;     % lower triangularity (minor radius unit)
%      sepa_option.zxdo      = 2.001;     % lower altitude X point (minor radius unit)
%      sepa_option.apdo      = 22.46;     % lower separatrix angle (R,X)  (LFS, degrees)
%      sepa_option.amdo      = 67.92;     % lower separatrix angle (-R,X)  (HFS, degrees)
%      sepa_option.b0        = 11.1;      % magnetic field at R0
%      sepa_option.delta     = 1.23;      % magnetic field at R0
%
% output:
%
%      z0dinput:      standard metis input data structure (see METIS documentation), contains data used for the computation or sample data structure in testing mode
%      tsnapshot:     time slice selected for performances evaluation
%
% function writed by J-F Artaud
% CVS version (created 2014/07/15)
%-----------------------------------------------------------------------
%
function [z0dinput,tsnapshot] = jt60sametissimulation(sepa_option,parameters_filename,reference_simulation)


% parameters declaration
if nargin < 1
  sepa_option = [];
end
if (nargin <= 1) && ~isstruct(sepa_option)

    valeur.reference_parameters 	= '';
    type.reference_parameters           = 'string';                    
    borne.reference_parameters          = '';  
    defaut.reference_parameters         = '';                
    info.reference_parameters           = 'file name that contains Parameters that will overwrite user defined Parameters (if empty, it is not used)';	

    valeur.sepa_option = 4.2;      
    type.sepa_option   = 'integer';
    borne.sepa_option  = {1,2,3,4.1,4.2,5.1,5.2,6};  
    defaut.sepa_option = 4.2;
    info.sepa_option   = 'Plasma shape: reference scenario for LCFS parametrisation\n(JT-60SA Research Plan, Version 3.3, 2016, March)';
    
    valeur.sepa_create = 'No';     
    type.sepa_create   = 'string';
    borne.sepa_create  = {'No','Yes'};  
    defaut.sepa_create = 'No';
    info.sepa_create   = 'Plasma shape: if = Yes, use LCFS provided by CREATE team (available for scenario 2); if = No, use LCFS generated by the program';    
    
    valeur.gas = 2;   % gas species as in METIS (1=H, 2=D, 3=DT & 4=He)      
    type.gas   = 'integer';
    borne.gas     = {1,2,4};  
    defaut.gas    = 2;
    info.gas      = 'Plasma composition: main gas species: 1 -> H, 2 -> D, 4 -> He';
    
    valeur.ip     = 3.5;   % plasma current (MA)  
    type.ip       = 'float';
    borne.ip      = [0.3,5.5];  
    defaut.ip     = 3.5;
    info.ip       = 'plasma current (MA)';

    valeur.b0     = 2.28;   
    type.b0       = 'float';
    borne.b0      = [0.3,2.3];  
    defaut.b0     = 2.8;
    info.b0       = 'vacuum magnetic field @ R_0 (T)';

    valeur.voltage_first = 'high';       
    type.voltage_first   = 'string';
    borne.voltage_first  = {'high','low'};  
    defaut.voltage_first = 'high';
    info.voltage_first   = 'Plasma initiation: burn through Vloop: high or low\n(H. Urano et al, Fusion Engineering and Design 100 (2015) 345-356)';
    mode.voltage_first   = 'advanced';
    
    valeur.flux = 'full';       
    type.flux   = 'string';
    borne.flux  = {'half','full'};  
    defaut.flux = 'full';
    info.flux   = 'Plasma initiation: available flux from pre-magnetisation: half CS current or full CS current\n(H. Urano et al, Fusion Engineering and Design 100 (2015) 345-356)';
    mode.flux   = 'advanced';
    
    valeur.density     = 4.2;   
    type.density       = 'float';
    borne.density      = [1,15];  
    defaut.density     = 4.2;
    info.density       = 'line averaged electron density during flattop (10^{19} m^{-3})';
    
    valeur.edge_density_factor     = 1;   
    type.edge_density_factor       = 'float';
    borne.edge_density_factor      = [0.1,10];  
    defaut.edge_density_factor     = 1;
    info.edge_density_factor       = 'edge density: multiplication factor applied to edge density scaling law:\nif > 0, ne_edge =  nea_factor * LCFS_denstity_scaling_law;\nif < 0,  ne_edge =  abs(nea_factor) * n_bar';
    mode.edge_density_factor   = 'advanced';
    
    valeur.H_H     = 1.4;   
    type.H_H       = 'float';
    borne.H_H      = [0.5,2];  
    defaut.H_H     = 1.4;
    info.H_H       = 'time confinement multiplication factor during H-mode phase';
    
    valeur.ITB = 'on';       
    type.ITB   = 'string';
    borne.ITB  = {'on','off'};  
    defaut.ITB = 'on';
    info.ITB   = 'allows or not ITB formation (on/off)';

    valeur.PNBI_N     = 10;   
    type.PNBI_N       = 'float';
    borne.PNBI_N      = [0 10];  
    defaut.PNBI_N     = 10;
    info.PNBI_N       = 'maximum power for NNBI during flattop (MW)';
    
    valeur.PNBI_P     = 24;   
    type.PNBI_P       = 'float';
    borne.PNBI_P      = [0 24];  
    defaut.PNBI_P     = 24;
    info.PNBI_P       = 'maximum power for PNBI during flattop (MW)';
    
    valeur.PICRH     = 0;   
    type.PICRH       = 'float';
    borne.PICRH      = [0 24];  
    defaut.PICRH     = 0;
    info.PICRH       = 'Optional ICRH source: maximum power for PICRH during flattop (MW);\nmust be 0 by default\n(this source can be used for scope studies)';
    mode.PICRH       = 'advanced';
    
    valeur.PECCD     = 7;   
    type.PECCD       = 'float';
    borne.PECCD      = [0 21];  
    defaut.PECCD     = 7;
    info.PECCD       = 'maximum power for ECRH/ECCD during flattop (MW):\nbaseline maximum power is 7 MW';

    valeur.PBREAK     = 1;   
    type.PBREAK       = 'float';
    borne.PBREAK      = [0 2];  
    defaut.PBREAK     = 1;
    info.PBREAK       = 'Plasma initiation: injected ECRH / ECCD power for assisted breakdown (MW);\nnote that only a small fraction of this power is absorbed';

    valeur.PRAMPUP     = 7;   
    type.PRAMPUP       = 'float';
    borne.PRAMPUP      = [0 7];  
    defaut.PRAMPUP     = 7;
    info.PRAMPUP       = 'ECRH / ECCD assisted ramp-up: maximum power at the end of ramp-up (MW),\npower increases in time depending on density and plasma current ';

    valeur.Recycling     = 0.97;   
    type.Recycling       = 'float';
    borne.Recycling      = [0,1-1e-4];  
    defaut.Recycling     = 0.97;
    info.Recycling       = 'Recycling coefficient';
    
    valeur.radiation = 'Matthews';       
    type.radiation   = 'Matthews';
    borne.radiation  = {'Lz','Matthews'};  
    defaut.radiation = 'Matthews';
    info.radiation   = 'line radiation model: model for line radiative power in core plasma (Lz = cooling rate or Matthews = Matthews scaling law)';
    mode.radiation   = 'advanced';

    valeur.SOL_model = 'scaling';       
    type.SOL_model   = 'string';
    borne.SOL_model  =  {'scaling','2_points'};  
    defaut.SOL_model = 'scaling';
    info.SOL_model   = 'SOL model: scaling law or 2 points model';
    mode.SOL_model   = 'advanced';

    valeur.runaway = 'off';       
    type.runaway   = 'string';
    borne.runaway  = {'on','off'};  
    defaut.runaway = 'off';
    info.runaway   = 'allows or not runaway electrons in the discharge (on/off)';
    mode.runaway   = 'advanced';

    valeur.breakdown = 'off';       
    type.breakdown   = 'string';
    borne.breakdown  = {'on','off'};  
    defaut.breakdown = 'off';
    info.breakdown   = 'turn on or off the breakdown model for plasma initiation';
    mode.breakdown   = 'advanced';

    valeur.duration     = 30;   
    type.duration       = 'float';
    borne.duration      = [1,1000];  
    defaut.duration     = 30;
    info.duration       = 'flat top duration (s)';
    
    valeur.f_dipdt_rampup     = 1;   
    type.f_dipdt_rampup       = 'float';
    borne.f_dipdt_rampup      = [0.3,3];  
    defaut.f_dipdt_rampup     = 1;
    info.f_dipdt_rampup       = 'Ramp-up rate: multiplication factor applied to dIp/dt for plasma current ramp-up with respect  to reference case:\nH. Urano et al, Fusion Engineering and Design 100 (2015) 345-356';
      
    valeur.fte_edge     = 1;   
    type.fte_edge       = 'float';
    borne.fte_edge      = [1,10];  
    defaut.fte_edge     = 1;
    info.fte_edge       = 'Multiplication factor applied to LCFS temperature (for studies of egde radiation and poloidal flux comsumption);\n Allows to choose between cold edge and ho edge plasma.\nInfluence ramp-up';
        
    valeur.f_dipdt_rampdown     = 1;   
    type.f_dipdt_rampdown       = 'float';
    borne.f_dipdt_rampdown      = [0.3,3];  
    defaut.f_dipdt_rampdown     = 1;
    info.f_dipdt_rampdown       = 'Ramp-down rate: multiplication factor applied to dIp/dt for plasma current ramp-down with respect  to reference case:\nH. Urano et al, Fusion Engineering and Design 100 (2015) 345-356';
 
    valeur.size_decrease_rampdown     = 1;   
    type.size_decrease_rampdown       = 'float';
    borne.size_decrease_rampdown      = [0.1,1];  
    defaut.size_decrease_rampdown     = 1;
    info.size_decrease_rampdown       = 'Fraction of flattop current from which the size of the plasam start shrinking during ramp-down';
     
    interface.ts = '';                    % nom de la fonction d'interfacage avec les donnees TS
    interface.jet = '';                   % nom de la fonction d'interfacage avec les donnees Jet

    z0dinput.valeur     = valeur;
    z0dinput.type       = type;
    z0dinput.borne      = borne;
    z0dinput.defaut     = defaut;
    z0dinput.info       = info;
    z0dinput.interface  = interface;
    z0dinput.mode  	= mode;
    

    z0dinput.description = sprintf('JT-60SA scenario generator; references:\nJT-60SA Research Plan, Version 3.3, 2016, March;\nH. Urano et al, Fusion Engineering and Design 100 (2015) 345-356;\nT. Wakatsuki et al., Plasma Phys. Contr. Fusion 57 (2015) 65005');   % description (une ligne) de la fonction

    z0dinput.help     = '';                            % nom du fichier d'aide s'il existe, sinon aide de la fonction
    z0dinput.gui      ='';                             % nom de l'interface graphique specifique si elle existe
    z0dinput.controle = '';                        % nom de la fonction de controle des valeurs si elle existe

    return

end
% gestion of input number and contents
if nargin < 3
    reference_simulation = '';
end
if nargin < 2
    parameters_filename = [];
end
if nargin < 1
    sepa_option = [];
end

if (nargin == 1) && isstruct(sepa_option)
      jt60sa_param = sepa_option;
      clear sepa_option;
      sepa_option = jt60sa_param.sepa_option;
else
     jt60sa_param = [];
end
if ~isempty(jt60sa_param) && isfield(jt60sa_param,'reference_parameters') && ~isempty(jt60sa_param.reference_parameters)
  fprintf('using reference parameters from %s\n',jt60sa_param.reference_parameters);
  info_loc = load(jt60sa_param.reference_parameters);
  parameters_filename = info_loc.post.z0dinput.option;
end

% structure of parameters for METIS
z0dinput = zerod_init(-2);
option = z0dinput.option;
option.gaz = 2;
option.neasser = 1;
option.Recycling = 0.97;
option.natural = 1;
option.ane = 11;
option.fn0a = 1;
option.fn0a_div = 0.1;
%
%option.scaling = 12;
option.scaling = 0;
option.dilution = 1;
option.tau_limitation = 'On';
option.l2hscaling = 3;
option.pl2h_mass_charge = 1;
option.modeh = 1;
option.hysteresis = 0;
option.configuration = 2;
option.l2hslope =  0.5;
option.usepped_scl = 2;
option.taurotmul = 0;
option.fintrinsic = 0.2;
option.xiioxie = -4.5;
%option.kishape = 0;
option.kishape = 3;
option.xieorkie = 0;
option.omega_shape = 0;
option.fstiff = 1;
option.ploss_exp = 'max_power';
option.xiioxie_ped = 0;
option.hmore_pped  = 2;
option.fpl2h_lim   = 2;
option.ki_expo     = 2;
option.plhthr      = 'P_LCFS';
option.grad_ped    = 3;
option.ode_pped    = 1;
option.adiabatic   = 1;

%
option.qdds = 1;
option.kidds = 3;
option.sitb = 2;
option.itb_sensitivity = 1;
option.itb_slope_max = 2;
option.smhd = 100;
option.tmhd = Inf;
%
option.runaway = 4;
option.modeboot = 2;
%
option.li = 1;
option.breakdown = - 8.5;
option.berror = 1e-4;
option.L_eddy = 0.84e-6;
option.R_eddy = 14e-6;
option.C_eddy = 1;
option.B_eddy = 0.12;
option.I_eddy = 0;
option.p_prefill = 0.7e-03;
%
option.zeff = 0;
option.faccu = 0;
option.heat_acc = 0;
option.fne_acc = 0;
option.zmax = 8;
option.zimp = 6;
option.rimp = 0.1;
option.density_model ='minconv';
%
option.frad = 1;
option.matthews = -1;
option.fte_edge = 1;
option.gaunt = 1;
option.noncoronal = 2;
option.z_prad = 'Stangeby';
%
option.sol_lscale = 0;
option.eioniz     = 0;
option.fnesol     = 0;
option.sol_model  = '2_points';
option.lcx = 1;
option.fcond = -1;
option.fmom = 0;
option.lambda_scale = 3;
option.sol_rad = 'decoupled';
option.fzmax_div = -1;
option.W_effect = 0;
option.factor_scale = 1;
option.fpower = 0.6000;
option.fR_target = 2.7 / 2.94;
option.mach_corr = 1;

%
option.angle_ece = 90;
option.synergie  = 1;
option.sens      = 1;
option.eccdmul   = 1;
%
option.angle_nbi = 90;
option.rtang     = 2.85;
option.zext      = 0.3;
option.einj      = 500000;
option.nbicdmul  = 1;
option.nb_nbi    = 2;
option.e_shielding = 'Honda-Sauter';
option.drs1        = 0;
option.dzs1        = 0;
%
option.angle_nbi2 = 0;
option.rtang2 = 2.85;
option.zext2  = 0.1;
option.einj2  = 85000;
option.nbicdmul2 = 1;
option.drs2   = 0;
option.dzs2   = 0;
%
option.lhmode = 5;  % used as ECCD system for breakdown
option.etalh  = 0;  % perpendicular
option.wlh = 0;
option.xlh = 0;
option.dlh = 0.2;
option.angle_ece2 = 90;

% used as third injector
option.fwcd = 0;
option.mino = 'T';
option.cmin = 0.1;
option.nphi = 100;
option.freq = 20;
option.icrh_width = 1;
option.fact_mino  = 0;
%
option.equi_ppar = 3;
option.signe = 1;
%option.cronos_regul= 2;
option.cronos_regul= 0;
option.available_flux = 36.5; %WB
option.machine = 'JT-60SA';
option.evolution = 0;
%
% reactivate fast ions ionisation of neutral beam
option.fast_ion_sbp   = 1;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UAL writing control parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


option.init_output_cpo = 0;
option.restart= '';
option.coreprof= 1;
option.coretransp= 1;
option.coresource_lhcd= 1;
option.coresource_eccd= 1;
option.coresource_icrh= 1;
option.coresource_nbicd= 1;
option.coresource_fusion= 1;
option.coreneutrals= 1;
option.coresource_radiation= 1;
option.coresource_cyclotron= 1;
option.neoclassic= 1;
option.coresource_full= 1;
option.equilibrium= 1;
option.grid_equi= 0;
option.scenario_occurrence= '';
option.coreprof_occurrence= '';
option.coretransp_occurrence= '';
option.coreneutrals_occurrence= '';
option.neoclassic_occurrence= '';
option.equilibrium_occurrence= '';
option.coresources_occurrence= '';

% default value for ITM
option.COCOS  = 13;

% overwriting
if ischar(parameters_filename)
    z0dinput = zerod_init(-2);
    if ~isempty(parameters_filename)
        option = z0doverwriteparam(parameters_filename,z0dinput.option);
    else
        option = z0dinput.option;
    end
elseif isstruct(parameters_filename)
    noms = fieldnames(parameters_filename);
    for k=1:length(noms)
	option.(noms{k}) = parameters_filename.(noms{k});
    end
    disp('references parameters have been setted out');
end

if isempty(reference_simulation)
    reference_simulation.gas = 2;               
    reference_simulation.ip = 3.5e6;
    reference_simulation.rb0 =  2.28.* 2.93 ;    
    reference_simulation.voltage_first = 'high'; 
    reference_simulation.flux =  'full';      
    reference_simulation.f_Greenwald = 0;      
    reference_simulation.density     = 4.2e19;        
    reference_simulation.edge_density_factor     = 1;        
    reference_simulation.H_H = 1.4;                
    reference_simulation.ITB = 'on'; 
    reference_simulation.shot = 1;                 
    reference_simulation.run  = 1;                 
    reference_simulation.PNBI_N = 10e6;            
    reference_simulation.PNBI_P = 24e6;              
    reference_simulation.PICRH = 0e6;              
    reference_simulation.PECCD    = 7e6;              
    reference_simulation.PBREAK   = 1e6;              
    reference_simulation.PRAMPUP  = 7e6;              
    reference_simulation.Recycling = 0.97;       
    reference_simulation.radiation  = 'Lz';               % model for line radiative power in core plasam (Lz = colling rate or Matthews)
    reference_simulation.SOL_model  = '2_points';         % SOL model: scaling or 2_points
    reference_simulation.runaway    = 'on';         
    reference_simulation.breakdown  = 'on';         
    reference_simulation.duration         = 30;      
    reference_simulation.sepa_create      = 'No';      
    reference_simulation.f_dipdt_rampup     = 1;   
    reference_simulation.f_dipdt_rampdown     = 1;   
    reference_simulation.fte_edge = 1;
    reference_simulation.size_decrease_rampdown = 1;
end

% input data
external_lcfs = 0;
% iter case
Kref = (1.687 + 2.001) / 2;
dref = (0.466 + 0.568) / 2;
fKup = 1.687 ./ Kref;
fKdo = 2.001 ./ Kref;
fdup = 0.46 ./ dref;
fddo = 0.568 ./ dref;
% to kept plasma into FW
fKup = fKup ./ fKdo;
fKdo = 1;
fdup = fdup ./ fddo;
fddo = 1;
% LCFS data
if isempty(sepa_option)
    sepa_option = 4.2;
end
if isstruct(sepa_option)
    % nothing to be done
    sepa_option_case = 0;
else
    sepa_option_case = sepa_option;
    clear sepa_option
    switch sepa_option_case
        % choix de la forme du plasma en plateau
        case 1
	  R = 2.96;
	  a = 1.18;
	  d = 0.53;
	  K = 1.95;
	  b0 = 2.25;
	  sn_dn = 2;
            
        case 2
	  R = 2.96;
	  a = 1.18;
	  d = 0.5;
	  K = 1.87;
	  b0 = 2.25;
	  sn_dn = 1;
            
        case 3
 	  R = 2.96;
	  a = 1.18;
	  d = 0.5;
	  K = 1.86;
	  b0 = 2.25;
	  sn_dn = 1;
            
        case 4.1
	  R = 2.93;
	  a = 1.14;
	  d = 0.41;
	  K = 1.81;
	  b0 = 2.28;
	  sn_dn = 1;
            
        case 4.2
	  R = 2.93;
	  a = 1.14;
	  d = 0.41;
	  K = 1.80;
	  b0 = 2.28;
	  sn_dn = 1;
            
        case 5.1
	  R = 2.97;
	  a = 1.11;
	  d = 0.47;
	  K = 1.9;
	  b0 = 1.72;
	  sn_dn = 1;
             
        case 5.2
 	  R = 2.96;
	  a = 1.12;
	  d = 0.45;
	  K = 1.91;
	  b0 = 1.62;
	  sn_dn = 1;
          
        case 6
 	  R = 2.97;
	  a = 1.11;
	  d = 0.51;
	  K = 1.91;
	  b0 = 1.41;
	  sn_dn = 1;
          
      otherwise
            % case with LCFS provided from external source
            external_lcfs = 1;
            error('not yet implemanted');
      end
      if sn_dn == 2
	  sepa_option.rxup      = d;     % upper triangularity (minor radius unit)
	  sepa_option.zxup      = K;    % upper altitude X point (minor radius unit)
	  sepa_option.apup      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
	  sepa_option.amup      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
	  sepa_option.ra        = R;       % major radius R0 (m) [6.2]
	  sepa_option.za        = 0;       % altitude of the magnetic axis (m) [0.9]
	  sepa_option.a         = a;         % minor radius (m) [2]
	  sepa_option.rxdo      = d;     % lower triangularity (minor radius unit)
	  sepa_option.zxdo      = K;       % lower altitude X point (minor radius unit)
	  sepa_option.apdo      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
	  sepa_option.amdo      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
	  sepa_option.delta     = 0.73;      % magnetic field at R0
	  sepa_option.b0        = b0 ./ (1 - sepa_option.a ./ sepa_option.ra - sepa_option.delta / sepa_option.ra);      % magnetic field at R0
	  sepa_option.nbp       = 201;       % number of points for the separatrix (depends on equilibrium module) [201]
	  sepa_option.mode       = 'elliptical';       % number of points for the separatrix (depends on equilibrium module) [201]
      else
	  sepa_option.rxup      = d * fdup;     % upper triangularity (minor radius unit)
	  sepa_option.zxup      = K * fKup;    % upper altitude X point (minor radius unit)
	  sepa_option.apup      = 0;       % upper separatrix angle (R,X)  (LFS, degrees)
	  sepa_option.amup      = 0;       % upper separatrix angle (-R,X) (HFS, degrees)
	  sepa_option.ra        = R;       % major radius R0 (m) [6.2]
	  sepa_option.za        = 0;       % altitude of the magnetic axis (m) [0.9]
	  sepa_option.a         = a;         % minor radius (m) [2]
	  sepa_option.rxdo      = d * fddo;     % lower triangularity (minor radius unit)
	  sepa_option.zxdo      = K * fKdo;       % lower altitude X point (minor radius unit)
	  sepa_option.apdo      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
	  sepa_option.amdo      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
	  sepa_option.delta     = 0.73;      % magnetic field at R0
	  sepa_option.b0        = b0 ./ (1 - sepa_option.a ./ sepa_option.ra - sepa_option.delta / sepa_option.ra);      % magnetic field at R0
	  sepa_option.nbp       = 201;       % number of points for the separatrix (depends on equilibrium module) [201]
	  sepa_option.mode       = 'elliptical';       % number of points for the separatrix (depends on equilibrium module) [201]
      end
      sepa_option.filename  = '';

      % try to read sepa file
      if isdeployed && ~isempty(dir('LCFS'))
	  pathm = 'LCFS';
      elseif  ~isempty(dir('LCFS'))
	  pathm = 'LCFS';
      elseif ~isempty(dir(fullfile(fileparts(which('jt60sawall.mat')),'LCFS')))
	  pathm = fullfile(fileparts(which('jt60sawall.mat')),'LCFS');
      else
	  % nodata
	  pathm = '';
      end
      if ~isempty(pathm)
	  sepafilename = fullfile(pathm,sprintf('SEP%s.mat',strrep(sprintf('%g',sepa_option_case),'.','_')));	  
	  sepa = load(sepafilename);
	  fprintf('reading LCFS moments from LCFS file: %s\n',sepafilename);

	  % calcul de R0 et Z0
	  % recalcul des parametres sur le vecteur final
	  rmin  = min(sepa.R);
	  rmax  = max(sepa.R);
	  a = 0.5 .* (rmax - rmin);
	  R = 0.5 .* (rmax + rmin);
	  zmin  = min(sepa.Z);
	  Kdo   = -zmin ./ a;
	  zmax  = max(sepa.Z);
	  Kup   = zmax ./ a;
	  z0   = (zmax + zmin) ./ 2;
	  rzmax = sepa.R(min(find(sepa.Z == zmax)));
	  rzmin = sepa.R(min(find(sepa.Z == zmin)));
	  dup = (R - rzmax) ./ a;
	  ddo = (R - rzmin) ./ a;
	  if sn_dn == 2
		sepa_option.rxup      = dup;     % upper triangularity (minor radius unit)
		sepa_option.zxup      = Kup;    % upper altitude X point (minor radius unit)
		sepa_option.apup      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
		sepa_option.amup      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
		sepa_option.ra        = R;       % major radius R0 (m) [6.2]
		sepa_option.za        = 0;       % altitude of the magnetic axis (m) [0.9]
		sepa_option.a         = a;         % minor radius (m) [2]
		sepa_option.rxdo      = ddo;     % lower triangularity (minor radius unit)
		sepa_option.zxdo      = Kdo;       % lower altitude X point (minor radius unit)
		sepa_option.apdo      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
		sepa_option.amdo      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
		sepa_option.delta     = 0.73;      % magnetic field at R0
		sepa_option.b0        = b0 ./ (1 - sepa_option.a ./ sepa_option.ra - sepa_option.delta / sepa_option.ra);      % magnetic field at R0
		sepa_option.nbp       = 201;       % number of points for the separatrix (depends on equilibrium module) [201]
		sepa_option.mode       = 'elliptical';       % number of points for the separatrix (depends on equilibrium module) [201]
	  else
		sepa_option.rxup      = dup;     % upper triangularity (minor radius unit)
		sepa_option.zxup      = Kup;    % upper altitude X point (minor radius unit)
		sepa_option.apup      = 0;      % upper separatrix angle (R,X)  (LFS, degrees)
		sepa_option.amup      = 0;       % upper separatrix angle (-R,X) (HFS, degrees)
		sepa_option.ra        = R;       % major radius R0 (m) [6.2]
		sepa_option.za        = 0;       % altitude of the magnetic axis (m) [0.9]
		sepa_option.a         = a;         % minor radius (m) [2]
		sepa_option.rxdo      = ddo;     % lower triangularity (minor radius unit)
		sepa_option.zxdo      = Kdo;       % lower altitude X point (minor radius unit)
		sepa_option.apdo      = 22.46;   % lower separatrix angle (R,X)  (LFS, degrees)
		sepa_option.amdo      = 67.92;   % lower separatrix angle (-R,X)  (HFS, degrees)
		sepa_option.delta     = 0.73;      % magnetic field at R0
		sepa_option.b0        = b0 ./ (1 - sepa_option.a ./ sepa_option.ra - sepa_option.delta / sepa_option.ra);      % magnetic field at R0
		sepa_option.nbp       = 201;       % number of points for the separatrix (depends on equilibrium module) [201]
		sepa_option.mode       = 'elliptical';       % number of points for the separatrix (depends on equilibrium module) [201]		
		
	  end	
	  % correction if moment LCFS is outside wall
	  % wall information
	  wall = load('jt60sawall');
	  rwall = wall.wall.data(1:end,1);
	  zwall = wall.wall.data(1:end,2);
	  %figure(21);clf;hold on
	  nbin_mem = 0;
	  apup = 0;
	  for k=0:22		
	      sepa_option.apup      = k;      % upper separatrix angle (R,X)  (LFS, degrees)
	      sepa_m = z0dsepanew2(1,sepa_option);
	      %plot(rwall,zwall,'b',sepa_m.R,sepa_m.Z,'r',sepa.R,sepa.Z,'g')
              % wall collision detection
              nbin = sum(zinout(sepa.R,sepa.Z,sepa_m.R,sepa_m.Z));
              if nbin > nbin_mem
		    apup = k;
              end
	  end
	  sepa_option.apup = apup;
	  sepa_option.filename = sepafilename;
      end

end

if ~isempty(jt60sa_param)

    reference_simulation.gas = jt60sa_param.gas;               
    reference_simulation.ip  = jt60sa_param.ip .* 1e6;
    reference_simulation.rb0 = jt60sa_param.b0 .* sepa_option.ra;    
    reference_simulation.voltage_first = jt60sa_param.voltage_first; 
    reference_simulation.flux =  jt60sa_param.flux;      
    reference_simulation.f_Greenwald = 0;      
    reference_simulation.density     = jt60sa_param.density .* 1e19;        
    reference_simulation.edge_density_factor     = jt60sa_param.edge_density_factor;        
    reference_simulation.H_H = jt60sa_param.H_H;                
    reference_simulation.ITB = jt60sa_param.ITB; 
    reference_simulation.shot = fix(10 .* jt60sa_param.sepa_option);                 
    reference_simulation.run  = 1;                 
    reference_simulation.PNBI_N = jt60sa_param.PNBI_N .* 1e6;            
    reference_simulation.PNBI_P = jt60sa_param.PNBI_P .* 1e6;              
    reference_simulation.PICRH = jt60sa_param.PICRH .* 1e6;              
    reference_simulation.PECCD    = jt60sa_param.PECCD .* 1e6;              
    reference_simulation.PBREAK   = jt60sa_param.PBREAK .* 1e6;              
    reference_simulation.PRAMPUP  = jt60sa_param.PRAMPUP .* 1e6;              
    reference_simulation.Recycling = jt60sa_param.Recycling;       
    reference_simulation.radiation  = jt60sa_param.radiation;               % model for line radiative power in core plasam (Lz = colling rate or Matthews)
    reference_simulation.SOL_model  = jt60sa_param.SOL_model;         % SOL model: scaling or 2_points
    reference_simulation.runaway    = jt60sa_param.runaway;         
    reference_simulation.breakdown    = jt60sa_param.breakdown;         
    reference_simulation.duration   = jt60sa_param.duration;     
    reference_simulation.sepa_create   = jt60sa_param.sepa_create;     
    reference_simulation.f_dipdt_rampup     = jt60sa_param.f_dipdt_rampup ;   
    reference_simulation.f_dipdt_rampdown   = jt60sa_param.f_dipdt_rampdown;  
    reference_simulation.fte_edge           = jt60sa_param.fte_edge;
    reference_simulation.size_decrease_rampdown = jt60sa_param.size_decrease_rampdown;

end

% pour la puissance dans le rampup
reference_simulation.PBREAK = max(eps,reference_simulation.PBREAK);

% open wrinting on standard output
%tokamak = sprintf('JT-60SA-R%d-a%d-RBt%d-Ip%d',ceil(sepa_option.ra*100),ceil(sepa_option.a*100),ceil(reference_simulation.rb0),ceil(reference_simulation.ip/1e6));
%tokamak = sprintf('JT-60SA-R%d-a%d-RBt%d-Ip%d',ceil(sepa_option.ra*100),ceil(sepa_option.a*100),ceil(reference_simulation.rb0),ceil(reference_simulation.ip/1e6));
tokamak = sprintf('JT-60SA-%g',sepa_option_case);
fprintf('Starting METIS simumlation for %s\n',tokamak);
root_name = '';

% other information
sepa_option.nbp       = 201;                 % number of points for the separatrix (depends on equilibrium module) [201]
sepa_option.mode       = 'elliptical';       % number of points for the separatrix (depends on equilibrium module) [201]
%sepa_option.za        = -(sepa_option.zxup - sepa_option.zxdo) .* sepa_option.a;       % altitude of the magnetic axis (m) [0.9]
z0_before_xpoint      = -(sepa_option.zxup - sepa_option.zxdo) .* sepa_option.a;       % altitude of the magnetic axis (m) [0.9]
sepa_option.za        = 0;
% from separatrix
[R,a,z0,K,d]   = sepamoment(sepa_option);

% end rampdown vertical position
%zlow = sepa_option.za - K .* a + a / 2;
zlow = z0 - K .* a + a / 2;

% magnetic rigidity
rb0 = reference_simulation.rb0;
b0  = rb0 ./ R;
% available poloidal flux from CS and PF coils (Wb)
switch reference_simulation.flux
    case 'full'
        available_flux =  36.5;
    otherwise
        available_flux =  36.5 ./ 2;
end
% vertical magnetic field flux contribution
available_flux = available_flux + 4.5 .* reference_simulation.ip ./ 5.5e6;

% flattop plasma current
ip   = reference_simulation.ip; %15e6;

% will scale with volume on ITER design
%  option for ECRH only or mixed ECRH/NBI
% the maximum power will also scale with L2H threshold
% ECRH flattop
pecrh1   = reference_simulation.PECCD;
% ecrh power are lineraly interpolated durant ramp-up and ramp-down
% preheat  (from start to xpoint, limiter mode)
p0_ecrh1 = 0e6;
% ramp up (from xpoint formation to H mode transition)
p1_ecrh1 = 0e6;
% end rampup (from hmode transition to end of ramp-up)
p2_ecrh1 = reference_simulation.PECCD;
% full power, up to ignition
% rampdown
p3_ecrh1 = reference_simulation.PECCD / 2;
%
pecrh2     = reference_simulation.PBREAK; 
p0_ecrh2   = reference_simulation.PBREAK;

% NBI :
pnbi1  =  reference_simulation.PNBI_N;
pnbi2  =  reference_simulation.PNBI_P;
picrh  =  reference_simulation.PICRH;

% heat source default parameters
xece  = 0;
xece_itb  = 0.5;

% physics model assumption
if reference_simulation.f_Greenwald > 0
    % Greenwald  fraction
    fnegr =  reference_simulation.f_Greenwald;
    % conversion (10^20 m^-3)
    nbar  = fnegr .* 1e20 .* (ip / 1e6) ./ (pi.* a .^ 2);
else
    nbar  = reference_simulation.density;
end
% enhancement factor for energy content on flat top
hmore = reference_simulation.H_H;

% plasma composition
iso   = 0;
ftnbi = 0;
switch reference_simulation.gas
    case 4
        zeff  = 4.2;
    otherwise
        zeff  = 2.1;
end
%%%%%%%%%%%%%%%%%%%%%%%%
% start data estimation
%%%%%%%%%%%%%%%%%%%%%%%%
% constant
mu0  = (4*pi.*1e-7);

% from reference:
% H Urano, Fusion engineering and design  100 (2015)  345-356
dipdt_ref   = 0.35e6; % A/s
dipdt = dipdt_ref .* reference_simulation.f_dipdt_rampup;
dipdt_down = (2/3) .* dipdt_ref .* reference_simulation.f_dipdt_rampdown;
fprintf('dIp/dt_{rampup} = %g (kA/s)\n',dipdt/1e3);
fprintf('dIp/dt_{rampdown, end of plasma} = %g (kA/s)\n',dipdt_down/1e3);

% dynamical parameters
% flattop current
ip_flattop = ip;
% current at witch the full power is applied
ip_full_power = 0.8 .* ip;
% current after breakdown @ 60 ms
switch reference_simulation.flux
    case 'full'
        ip_ini = 0.21e6;
    otherwise
        ip_ini = 0.19e6;
end
% plasam current for the back transition to L-mode (reduced magnetic energy by a factor 2)
ip_dn = ip ./ sqrt(2);



% density at application of full power
nbar_full_power = (2/3) .* ip_full_power ./ ip .* min(nbar,1e20 .* (ip_full_power / 1e6) ./ (pi.* a .^ 2));
% used of scaling on density for minimal L2H power threshold. reference: F. Ryter N.F. 2014
nbar_l2h_min    = 0.7e19 .* (ip_full_power ./ 1e6) .^ 0.34 .* a .^ -0.95 .* b0 .^ 0.62 .* (R ./ a) .^ 0.4;
nbar_full_power = min(nbar_full_power,nbar_l2h_min);
% denstity at the start of flatop
nbar_flattop    = min(0.5 .* (nbar + nbar_full_power),1e20 .* (ip / 1e6) ./ (pi.* a .^ 2));
% density after breakdown @ 60ms
%a_ini = 1.043;
R_ini = 2.8;
a_ini = 2.8 - 1.705;
q95_ini = 5 .* a_ini .^ 2 .* b0 ./ (ip_ini./1e6) ./ R_ini .* (1.17 - 0.65 .* a_ini ./ R_ini) ./ (1 - (a_ini./R_ini) .^ 2 ) .^ 2;
negr_ini = 1;
nini  = min(negr_ini .* 1e20 .* (ip_ini / 1e6) ./ (pi.* a_ini .^ 2), ...
    1e20 .* (b0 ./ q95_ini ./ R_ini) .^ 0.6  .*  0.25);


% times of interrest
% start of the simulation
t_start = 0;
% time for breakdown
t_break = 60e-3;
% time for switch resistor and end of ECRH breakdown
t_ms    =  0.29;
switch reference_simulation.voltage_first
    case 'high'
        ip_ms = 0.56e6;
        t_ms    =  0.29;
    otherwise
        ip_ms = ip_ini .* 0.066 ./ 0.06;
        t_ms    =  0.066;
end
q95_ms = 5 .* a_ini .^ 2 .* b0 ./ (ip_ms./1e6) ./ R_ini .* (1.17 - 0.65 .* a_ini ./ R_ini) ./ (1 - (a_ini./R_ini) .^ 2 ) .^ 2;
nms  = min(negr_ini .* 1e20 .* (ip_ms / 1e6) ./ (pi.* a_ini .^ 2), ...
    1e20 .* (b0 ./ q95_ms ./ R_ini) .^ 0.6  .*  0.25);
nms = max(nini,nms);

switch reference_simulation.flux
    case 'full'
        
        % time before xpoint
        t_xpoint        = 3.74 ./ reference_simulation.f_dipdt_rampup;
        t_before_xpoint = t_xpoint - 0.7 /2;
        t_after_xpoint  = t_xpoint + 0.7 /2;
        % plasma current at  X-point formation
        ip_xpoint    = 1.51e6;
        % time for full power
        t_full_power = 12.5 ./ reference_simulation.f_dipdt_rampup;
        % start of the flattop
        t_flattop    = 15.14 ./ reference_simulation.f_dipdt_rampup;
        % time for full density (just a estimation)
        t_flattop_plus = min(t_flattop + reference_simulation.duration / 2,24 ./ reference_simulation.f_dipdt_rampup);
        
    otherwise
        
        % time before xpoint
        t_xpoint        = 2.42 ./ reference_simulation.f_dipdt_rampup;
        t_before_xpoint = t_xpoint - 0.7 /2;
        t_after_xpoint  = t_xpoint + 0.7 /2;
        % plasma current at  X-point formation
	switch reference_simulation.voltage_first
	    case 'high'
	        ip_xpoint    = 0.76e6;
	    otherwise
	        ip_xpoint    = 1e6;
	end
        % time for full power
        t_full_power = 5.47 ./ reference_simulation.f_dipdt_rampup;
        % start of the flattop
        t_flattop    = 6.3 ./ reference_simulation.f_dipdt_rampup;
        % time for full density (just a estimation)
        t_flattop_plus = min(t_flattop + reference_simulation.duration / 2,15.14 ./ reference_simulation.f_dipdt_rampup);
        
end
% reference density
% saturation density
nsat_xpoint = min(1e20 .* (ip_xpoint ./ 1e6) ./ (pi.* a .^ 2),0.06e20 .* (ip_xpoint ./ 1e6) .* R .* sqrt(reference_simulation.gas) ./ K ./ a .^ (5/2));


% density at x-point transition
q95_x = 5 .* a .^ 2 .* b0 ./ (ip_xpoint ./ 1e6) ./ R .* (1 + K .^ 2 .*  ...
    (1 + 2 .* d .^ 2 - 1.2 .* d .^ 3) ./ 2) .* (1.17 - 0.65 .* a ./ R) ./  ...
    (1 - (a./R) .^ 2 ) .^ 2;
%n_xpoint  = max(negr_ini .* 1e20 .* (ip_xpoint ./ 1e6) ./ (pi.* a .^ 2), ...
%    1e20 .* (b0 ./ q95_x ./ R) .^ 0.6  .*  0.25);
n_xpoint  = min(nsat_xpoint,1e20 .* (b0 ./ q95_x ./ R) .^ 0.6  .*  0.25);
n_xpoint = min(n_xpoint,nbar_l2h_min);
n_xpoint = max(nms,n_xpoint);
nbar_full_power = max(n_xpoint,nbar_full_power);
nbar_flattop    = max(nbar_full_power,nbar_flattop);

% data for rampdown
% simulation duration
% end time (wee look for a pulse duration greater than 2 hours)
% duration is increased to be sure to capture the time when all poloial flux is consummed
tend = t_flattop + reference_simulation.duration;
% time for back transition in L-mode
% there is trade between flux consumption and l_i change
tdn          = tend + (ip_flattop - ip_dn) ./ (dipdt ./ reference_simulation.f_dipdt_rampup  .* reference_simulation.f_dipdt_rampdown + dipdt_down) .* 2;
% time to back transition to limiter
if ip_dn > ip_xpoint
    tdip         = tdn  +  (ip_dn - ip_xpoint) ./ dipdt_down;
else
    tdip         = tdn  +  (ip_dn - (ip_dn + ip_ini) / 2) ./ dipdt_down;
end
% end of ramp-down simulation (as fast as possible => limter mode)
%tv0          = tdip + (ip_xpoint - ip_ini) ./ dipdt_down ./ 2;
tv0          = tdip + (ip_xpoint - ip_ini) ./ (dipdt ./ reference_simulation.f_dipdt_rampup .* reference_simulation.f_dipdt_rampdown);

disp('Key times:');
fprintf('Starting time of the simulation: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_start,1e3/1e6,1e17/1e19);
fprintf('Beakdown time : %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_break,ip_ini/1e6,nini./1e19);
fprintf('End resitor network use: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_ms,ip_ms/1e6,nms./1e19);
fprintf('X-point formation: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_xpoint,ip_xpoint/1e6,n_xpoint./1e19);
fprintf('Full power time: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_full_power,ip_full_power/1e6,nbar_full_power./1e19);
fprintf('Start of flat-top: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_flattop,ip_flattop/1e6,nbar_flattop./1e19);
fprintf('End of full power assited phase: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',t_flattop_plus,ip_flattop/1e6,nbar./1e19);
fprintf('End of flat-top: %g s @ Ip = %g MA & n_bar = %g 10^{19} m^{-3}\n',tend,ip_flattop/1e6,nbar./1e19);
fprintf('H to L back transition: %g s @ Ip = %g MA & n_bar > %g 10^{19} m^{-3}\n',tdn,ip_dn/1e6,nini./1e19);
fprintf('back transition to limiter: %g s @ Ip = %g MA & n_bar > %g 10^{19} m^{-3}\n',tdip,ip_xpoint/1e6,nini./1e19);
fprintf('End of simulation/plasma  : %g s @ Ip = %g MA & n_bar > %g 10^{19} m^{-3}\n',tv0,ip_ini/1e6,nini./1e19);

% ICRH
rres  = R  - 0.2 .* a;
bres  = b0 .* R ./ rres;
ag    = 1;
zg    = 1;
harm  = 1;
freq  = harm .* bres .* (95.5e6 .* zg ./ ag) ./ (2 .* pi .* 1e6); % MHz


% time slices for the computation
temps = t_start:1e-3:t_break;
temps = union(temps,t_break:5e-3:t_ms);
temps = union(temps,t_ms:1e-2:t_after_xpoint);
temps = union(temps,t_after_xpoint:0.1:t_flattop_plus);
temps = union(temps,t_flattop_plus:0.5:tend);
temps = union(temps,tend:0.1:tv0)';

% pre-parametrised METIS input data
z0dinput = zerod_scalaire(temps,b0,R,a,K,d,ip,nbar,pecrh2,picrh,pecrh1,pnbi1+pnbi2,zeff,xece,hmore,iso,ftnbi,0);
% load standard reference parameters
z0dinput.option = option;

%% switch off ip control during ramp down
%%z0dinput.option.vref = 0;
%%z0dinput.option.tswitch = tv0;
z0dinput.option.vloop = 0;
% offset to prevent to early H mode transition after X point formation (in the error bar of scaling for L 2 H transition)
z0dinput.option.l2hmul = 2 + (p0_ecrh1 + p0_ecrh2 + ip_ini) ./ 1e6;
% ICRH is configured to be used as NBI like source
z0dinput.option.freq =freq;
% random shot number
z0dinput.option.shot = reference_simulation.shot;
% decoration
z0dinput.option.machine = tokamak;
% for backward compatibility
z0dinput.machine = z0dinput.option.machine;
z0dinput.shot = z0dinput.option.shot;

% flux consumption
z0dinput.option.available_flux = available_flux;
% main gas
z0dinput.option.gaz = reference_simulation.gas;
% edge density
z0dinput.option.nea_factor = reference_simulation.edge_density_factor;        
% recycling
z0dinput.option.Recycling = reference_simulation.Recycling;        
% model for line radiative power in core plasam (Lz = colling rate or Matthews)
switch reference_simulation.radiation 
case 'Matthews'
  z0dinput.option.matthews  =  1;
otherwise
  z0dinput.option.matthews  =  -1;
end
 % SOL model: scaling or 2_points
z0dinput.option.sol_model = reference_simulation.SOL_model;        

% with or without ITB
switch upper(reference_simulation.ITB)
case 'ON'
  z0dinput.option.sitb = 2;
  z0dinput.option.hmore_pped  = 0;
otherwise
  z0dinput.option.sitb = 0;
  z0dinput.option.hmore_pped  = 2;
end
% runaway model
switch upper(reference_simulation.runaway)
case 'ON'
  switch upper(reference_simulation.breakdown)
  case 'ON'
    z0dinput.option.runaway = 5;
  otherwise
    z0dinput.option.runaway = 4;  
  end
otherwise
  z0dinput.option.runaway = 0;
end
% breakdown model
switch upper(reference_simulation.breakdown)
case 'ON'
  z0dinput.option.berror = 1e-4;
otherwise
  z0dinput.option.berror = 0;
end
% edge temperature
z0dinput.option.fte_edg = reference_simulation.fte_edge;

% waveforms control nodes generation
tv      = [];     % time  nodes
ipv     = [];     % plasma currentnodes
nv      = [];     % line averaged density nodes
picrhv  = [];     % ICRH power nodes
plhv    = [];     % LHCD/ECRH2 power nodes
pecrhv  = [];     % ECRH power nodes
pnbi1v  = [];     % NBI1 power nodes
pnbi2v  = [];     % NBI2 power nodes
Rv      = [];     % major radius nodes
av      = [];     % minor radius nodes
Kv      = [];     % averaged elongation nodes
dv      = [];     % averaged triangularity nodes
z0v     = [];     % plasma vertical shift nodes
isov    = [];     % isotopic ration nT/nD nodes
xecev   = [];     % ECRH maximum depostion position nodes
hmore   = [];     % confinement enhancement nodes

% first time
tv(end+1)      = t_start;
ipv(end+1)     = 1e3;
nv(end+1)      = 1e17;
picrhv(end+1)  = 0;
plhv(end+1)    = reference_simulation.PBREAK;
pecrhv(end+1)  = 0;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = R_ini ./ R;
av(end+1)      = a_ini ./ a;
Kv(end+1)      = 0;
dv(end+1)      = 0;
z0v(end+1)     = 0;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;

% first time after breakdown
tv(end+1)      = t_break;
ipv(end+1)     = ip_ini;
nv(end+1)      = nini;
picrhv(end+1)  = 0;
plhv(end+1)    = reference_simulation.PBREAK;
pecrhv(end+1)  = p0_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = R_ini ./ R;
av(end+1)      = a_ini ./ a;
Kv(end+1)      = 0;
dv(end+1)      = 0;
z0v(end+1)     = 0;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;

% MS time
tv(end+1)      = t_ms;
ipv(end+1)     = ip_ms;
nv(end+1)      = nms;
picrhv(end+1)  = 0;
plhv(end+1)    = 0;
pecrhv(end+1)  = p0_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = R_ini ./ R;
av(end+1)      = a_ini ./ a;
Kv(end+1)      = 0;
dv(end+1)      = 0;
z0v(end+1)     = (z0 + z0_before_xpoint) ./ 2;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;

% time before X point formation
tv(end+1)      = t_before_xpoint;
ipv(end+1)     = ip_xpoint;
nv(end+1)      = n_xpoint;
picrhv(end+1)  = 0;
plhv(end+1)    = 0;
pecrhv(end+1)  = p1_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = (z0 + z0_before_xpoint) ./ 2;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;


% time for X point formation
tv(end+1)      = t_xpoint;
ipv(end+1)     = ip_xpoint;
nv(end+1)      = n_xpoint;
picrhv(end+1)  = 0;
plhv(end+1)    = 0;
pecrhv(end+1)  = p1_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = 3/4 .* z0 + z0_before_xpoint .* 1./ 4;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;

% time after X point formation
tv(end+1)      = t_after_xpoint;
ipv(end+1)     = ip_xpoint;
nv(end+1)      = n_xpoint;
picrhv(end+1)  = 0;
plhv(end+1)    = 0;
pecrhv(end+1)  = p1_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 0;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = z0;
isov(end+1)    = 1;
xecev(end+1)   = 0;
hmore(end+1)   = 1;

% time for full power and H-mode transition
tv(end+1)      = t_full_power;
ipv(end+1)     = ip_full_power;
nv(end+1)      = nbar_full_power;
picrhv(end+1)  = 1;
plhv(end+1)    = 0;
pecrhv(end+1)  = p2_ecrh1;
pnbi1v(end+1)  = 0;
pnbi2v(end+1)  = 1;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = z0;
isov(end+1)    = 1;
xecev(end+1)   = xece;
hmore(end+1)   = reference_simulation.H_H;

% start of flattop
tv(end+1)      = t_flattop;
ipv(end+1)     = ip_flattop;
nv(end+1)      = nbar_flattop;
picrhv(end+1)  = 1;
plhv(end+1)    = 0;
pecrhv(end+1)  = pecrh1;
pnbi1v(end+1)  = 1;
pnbi2v(end+1)  = 1;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = z0;
isov(end+1)    = 1;
xecev(end+1)   = xece_itb;
hmore(end+1)   = reference_simulation.H_H;

% full density 
tv(end+1)      = t_flattop_plus;
ipv(end+1)     = ip_flattop;
nv(end+1)      = nbar;
picrhv(end+1)  = 1;
plhv(end+1)    = 0;
pecrhv(end+1)  = pecrh1;
pnbi1v(end+1)  = 1;
pnbi2v(end+1)  = 1;
Rv(end+1)      = 1;
av(end+1)      = 1;
Kv(end+1)      = 1;
dv(end+1)      = 1;
z0v(end+1)     = z0;
isov(end+1)    = 1;
xecev(end+1)   = xece_itb;
hmore(end+1)   = reference_simulation.H_H;

% end of flattop
tv(end+1)      =  tend;
ipv(end+1)     =  ip_flattop;
nv(end+1)      =  nbar;
picrhv(end+1)  =  1;
plhv(end+1)    =  0;
pecrhv(end+1)  =  pecrh1;
pnbi1v(end+1)  =  1;
pnbi2v(end+1)  =  1;
Rv(end+1)      =  1;
av(end+1)      =  1;
Kv(end+1)      =  1;
dv(end+1)      =  1;
z0v(end+1)     =  z0;
isov(end+1)    =  1;
xecev(end+1)   =  xece_itb;
hmore(end+1)   =  reference_simulation.H_H;

% shutdown NBI (and ICRH if present) 50%
% during start of rampdown
tv(end+1)      =  tend + (tdn - tend) ./ 3;
ipv(end+1)     =  ip_flattop - (ip_flattop - ip_dn) ./ 3;
nv(end+1)      =  nbar .* ipv(end) ./ ip_flattop;
picrhv(end+1)  =  0;
plhv(end+1)    =  0;
pecrhv(end+1)  =  p3_ecrh1;
pnbi1v(end+1)  =  0.5;
pnbi2v(end+1)  =  0.5;
Rv(end+1)      =  1;
av(end+1)      =  1;
Kv(end+1)      =  1;
dv(end+1)      =  1;
z0v(end+1)     =  z0;
isov(end+1)    =  1;
xecev(end+1)   =  xece_itb;
hmore(end+1)   =  1;

% shutdown NBI
% during start of rampdown
tv(end+1)      =  tend + 2 .* (tdn - tend) ./ 3;
ipv(end+1)     =  ip_flattop - 2 .* (ip_flattop - ip_dn) ./ 3;
nv(end+1)      =  nbar .* ipv(end) ./ ip_flattop;
picrhv(end+1)  =  0;
plhv(end+1)    =  0;
pecrhv(end+1)  =  p3_ecrh1;
pnbi1v(end+1)  =  0;
pnbi2v(end+1)  =  0;
Rv(end+1)      =  1;
av(end+1)      =  1;
Kv(end+1)      =  1;
dv(end+1)      =  1;
z0v(end+1)     =  z0;
isov(end+1)    =  1;
xecev(end+1)   =  xece;
hmore(end+1)   =  1;

% back transition to L-mode
tv(end+1)      =  tdn;
ipv(end+1)     =  ip_dn;
nv(end+1)      =  min(nv(end),nbar_flattop .* ipv(end) ./ ip_flattop);
picrhv(end+1)  =  0;
plhv(end+1)    =  0;
pecrhv(end+1)  =  0;
pnbi1v(end+1)  =  0;
pnbi2v(end+1)  =  0;
Rv(end+1)      =  1;
av(end+1)      =  1;
Kv(end+1)      =  1;
dv(end+1)      =  1;
z0v(end+1)     =  z0;
isov(end+1)    =  1;
xecev(end+1)   =  0;
hmore(end+1)   =  1;

% back transition to limiter
tv(end+1)      =  tdip;
if ip_dn > ip_xpoint
    ipv(end+1)     =  ip_xpoint;
else
    ipv(end+1)     =  (ip_dn + ip_ini) / 2;
end
nv(end+1)      =  nini;
picrhv(end+1)  =  0;
plhv(end+1)    =  0;
pecrhv(end+1)  =  0;
pnbi1v(end+1)  =  0;
pnbi2v(end+1)  =  0;
Rv(end+1)      =  1;
av(end+1)      =  1;
Kv(end+1)      =  1;
dv(end+1)      =  1;
z0v(end+1)     =  z0;
isov(end+1)    =  0.7;
xecev(end+1)   =  0;
hmore(end+1)   =  1;

% end of controlled ramp-down
tv(end+1)      =  tv0;
ipv(end+1)     =  ip_ini;
nv(end+1)      =  nini;
picrhv(end+1)  =  0;
plhv(end+1)    =  0;
pecrhv(end+1)  =  0;
pnbi1v(end+1)  =  0;
pnbi2v(end+1)  =  0;
Rv(end+1)      =  max(1.71 ./ sepa_option.ra,1 - 0.8 .* sepa_option.a ./ sepa_option.ra .* sepa_option.rxdo);
av(end+1)      =  0.3;
Kv(end+1)      =  0;
dv(end+1)      =  0;
z0v(end+1)     =  zlow;
isov(end+1)    =  0.5;
xecev(end+1)   =  0;
hmore(end+1)   =  1;


% scales
picrhv  = picrhv  .* picrh;
pnbi1v  = pnbi1v  .* pnbi1;
pnbi2v  = pnbi2v  .* pnbi2;
Rv      = Rv .* R;
av      = av .* a;
Kv      = Kv .* (K - 1) + 1;
dv      = dv .* d;

% time interpolation
z0dinput.cons.ip = pchip(tv,ipv,temps);
z0dinput.cons.picrh = zinterpnc(tv,picrhv,temps);
z0dinput.cons.pnbi = zinterpnc(tv,pnbi1v,temps) + sqrt(-1) .* zinterpnc(tv,pnbi2v,temps);
z0dinput.cons.plh = zinterpnc(tv,plhv,temps);
% change for break down 500 ms ECRH
z0dinput.cons.plh(temps < 0.5) = reference_simulation.PBREAK;
z0dinput.cons.pecrh = zinterpnc(tv,pecrhv,temps);
%indft = find((temps > t_xpoint) & (temps < t_full_power));
%z0dinput.cons.pecrh(indft) = pchip(tv,pecrhv,temps(indft));
z0dinput.cons.iso(:) = 0;
if z0dinput.option.nb_nbi > 1
    z0dinput.cons.ftnbi = (1 + sqrt(-1)) .* ftnbi .* ones(size(z0dinput.cons.ftnbi));
else
    z0dinput.cons.ftnbi = ftnbi .* ones(size(z0dinput.cons.ftnbi));
end
z0dinput.geo.a   = pchip(tv,av,temps);
z0dinput.geo.R   = pchip(tv,Rv,temps);
% kept contact on limiter
gap_wall = (z0dinput.geo.R - z0dinput.geo.a) - (R_ini - a_ini);
z0dinput.geo.R(temps <= t_before_xpoint) = z0dinput.geo.R(temps <= t_before_xpoint) - gap_wall(temps <= t_before_xpoint);
indtox = find((temps >= t_before_xpoint) & (temps <= t_after_xpoint));
z0dinput.geo.R(indtox) = interp1(temps([indtox(1)-1,indtox(end)]),z0dinput.geo.R([indtox(1)-1,indtox(end)]),temps(indtox),'linear','extrap');
% after x point desapear
z0dinput.geo.R(temps > tdip) = z0dinput.geo.R(temps > tdip) - gap_wall(temps > tdip);
%
z0dinput.geo.K   = pchip(tv,Kv,temps);
z0dinput.geo.d   = pchip(tv,dv,temps);
z0dinput.geo.z0  = pchip(tv,z0v,temps);
z0dinput.cons.nbar = pchip(tv,nv,temps);
indlinn = find((temps > tdn) & (temps < tdip));
z0dinput.cons.nbar(indlinn) = interp1(temps([indlinn(1),indlinn(end)]),z0dinput.cons.nbar([indlinn(1),indlinn(end)]),temps(indlinn),'linear','extrap');
z0dinput.cons.xece = pchip(tv,xecev,temps);
z0dinput.cons.hmore = zinterpnc(tv,hmore,temps);
z0dinput.cons.zeff =  min(zeff,2.3) - min(zeff - 1,1.3) .* max(0,(z0dinput.cons.temps - t_xpoint) ./ (z0dinput.cons.temps(1) - t_xpoint));
zeff_dens =  (zeff - 1) .*  min(ip_xpoint  ./ z0dinput.cons.ip,max(z0dinput.cons.nbar) ./ z0dinput.cons.nbar) + 1;

% we have Zeff after early ramp up that depend on input power (impurities sources and seeding to protect divertor)
pin   = z0dinput.cons.ip + real(z0dinput.cons.pnbi)  + imag(z0dinput.cons.pnbi) + z0dinput.cons.pecrh;
fzeff = min(1, pin ./ max(pin)) .* (z0dinput.cons.temps > t_xpoint);
fzeff = sgolayfilt(fzeff,1,3);
z0dinput.cons.zeff = z0dinput.cons.zeff .* (1 - fzeff) + zeff .* fzeff;
% Zeff in unchanged during ramp-down up to the limited phase; the fuelling is limited during this phase, it can be difficult to remove impurities
z0dinput.cons.zeff(z0dinput.cons.temps > tend) = z0dinput.cons.zeff(z0dinput.cons.temps == tend);
% Zeff evolution during limited final phase
fzeff = ones(size(z0dinput.cons.zeff));
fzeff(z0dinput.cons.temps > tdip) = zeff_dens(z0dinput.cons.temps > tdip) < zeff;
fzeff = sgolayfilt(fzeff,1,3);
z0dinput.cons.zeff = zeff_dens .* (1 - fzeff) + z0dinput.cons.zeff .* fzeff;
% limits for formula inside METIS
z0dinput.cons.zeff = max(1,min(7, sgolayfilt(z0dinput.cons.zeff,1,3)));
% power during ramp-up
ind1 = max(find(z0dinput.cons.plh > 0)) + 1 ;
ind2 = find((temps >= t_full_power),1)  - 1;
z0dinput.cons.plh(ind1:ind2)  = reference_simulation.PRAMPUP .* min(1,z0dinput.cons.nbar(ind1:ind2) ./ max(z0dinput.cons.nbar(ind1:ind2)) .* ...
                                z0dinput.cons.ip(ind1:ind2) ./ max(z0dinput.cons.ip(ind1:ind2)));

% LCFS computation
sepa_option.ton       = t_after_xpoint;
sepa_option.toff      = tdip;
z0dinput = z0separatrix(z0dinput,sepa_option,0);
z0dinput.geo.b0 = rb0 ./ z0dinput.geo.R;

% print separtrix parameters:
disp('Separatrix parameters (flat top phase):');
sepa_option
sepa_option = rmfield(sepa_option,'filename');

switch reference_simulation.sepa_create
    case 'Yes'
        z0dinput = z0separatrix_jt60sa_scenario2_create(z0dinput);
    otherwise
        % wall information
        wall = load('jt60sawall');
        rwall = wall.wall.data(1:end,1);
        zwall = wall.wall.data(1:end,2);
        
        % decrease of elongation during start of rampdown
        %
        indkreduc = find((z0dinput.cons.temps > tend) & ((z0dinput.cons.ip ./ ip_flattop) <= reference_simulation.size_decrease_rampdown));
        ip_reduc  = ip_flattop .* reference_simulation.size_decrease_rampdown;
        % reference xpoint position
        z_xpoint_ref = min(z0dinput.exp0d.Zsepa(indkreduc(1) - 1,:)) + z0dinput.geo.z0(indkreduc(1) - 1);
        % minimal value of elongation after decrease
        % try to keep q_95 = Constant during first part of ramp down and try to increase vertical stability
        fKreduc    = sqrt(max(1,(K .^ 2 + 1) .* z0dinput.cons.ip ./ ip_reduc - 1)) ./ K;
        zxdo_mem = sepa_option.zxdo;
        zxup_mem = sepa_option.zxup;
        rxup_mem = sepa_option.rxup;
        rxdo_mem = sepa_option.rxdo;
        apup_mem = sepa_option.apup;
        amup_mem = sepa_option.amup;
        a_mem    = sepa_option.a;
        ra_mem   = sepa_option.ra;
        Kref = z0dinput.geo.K(indkreduc(1) - 1);
        dref = z0dinput.geo.d(indkreduc(1) - 1);
        
        for k = indkreduc'
            sepa_option.a = min(z0dinput.geo.a(k),max(0.1 .* a_mem,fKreduc(k) .* a_mem));
            sepa_option.ra = max(min(rwall) + 1e-2,max(min(z0dinput.geo.R(indkreduc)),ra_mem + (sepa_option.a - a_mem)));
            sepa_option.zxup = max(1,fKreduc(k) .* zxup_mem);
            sepa_option.zxdo = max(1,fKreduc(k) .* zxdo_mem);
            sepa_option.rxup = rxup_mem .* z0dinput.cons.ip(k) ./ ip_flattop .* fKreduc(k);
            sepa_option.rxdo = rxdo_mem .* z0dinput.cons.ip(k) ./ ip_flattop .* fKreduc(k);
            sepa_option.apup = apup_mem .* z0dinput.cons.ip(k) ./ ip_flattop .* fKreduc(k);
            sepa_option.amup = amup_mem .* z0dinput.cons.ip(k) ./ ip_flattop .* fKreduc(k);
            z0d1t = zerod_get1t(z0dinput,k);
            z0d1t.geo.K = min(z0d1t.geo.K,max(1,Kref .* fKreduc(k)));
            z0d1t.geo.d = min(z0d1t.geo.d,dref .* z0dinput.cons.ip(k) ./ ip_flattop);
            z0d1t.geo.a = sepa_option.a;
            z0d1t.geo.R = sepa_option.ra;
            if z0dinput.cons.temps(k) > tdip
                gap_wall = (z0d1t.geo.R - z0d1t.geo.a) - (R_ini - a_ini);
                % after x point desapear
                z0dinput.geo.R(k) = z0dinput.geo.R(k) - gap_wall;
            end
            rep = z0separatrix(z0d1t,sepa_option,0);
            z0dinput.geo.K(k) = rep.geo.K;
            z0dinput.geo.d(k) = rep.geo.d;
            z0dinput.geo.R(k) = rep.geo.R;
            z0dinput.geo.a(k) = rep.geo.a;
            z0dinput.exp0d.Rsepa(k,:) = rep.exp0d.Rsepa(1,:) - (max(rep.exp0d.Rsepa(1,:)) + min(rep.exp0d.Rsepa(1,:))) ./ 2 + z0d1t.geo.R;
            % kept xpoint position fixed
            z0dinput.exp0d.Zsepa(k,:) = rep.exp0d.Zsepa(1,:) - min(rep.exp0d.Zsepa(1,:)) - z0d1t.geo.z0 + z_xpoint_ref;
            % wall collision detection
            mask = zinout(rwall,zwall-z0dinput.geo.z0(k),z0dinput.exp0d.Rsepa(k,:),z0dinput.exp0d.Zsepa(k,:));
            if any(mask == 0)
                dz = 1e-3;
                da = -1e-3;
                nb = sum(mask == 0);
                nb_mem = nb;
                iter_loop = 1000;
                while (nb ~= 0) && (iter_loop > 0)
                    mask = zinout(rwall,zwall-z0dinput.geo.z0(k),z0dinput.exp0d.Rsepa(k,:),z0dinput.exp0d.Zsepa(k,:));
                    nb = sum(mask == 0);
                    if ((nb > nb_mem) && (iter_loop < 500)) || (nb == 0)
                        break;
                    end
                    nb_mem = nb;
                    iter_loop = iter_loop - 1;
                    z0dinput.geo.z0(k) = z0dinput.geo.z0(k) + dz;
                    z0dinput.geo.a(k) = z0dinput.geo.a(k) + da;
                    z0dinput.geo.R(k) = z0dinput.geo.R(k) + da;
                    if z0dinput.cons.temps(k) > tdip
                        gap_wall = (z0d1t.geo.R - z0d1t.geo.a) - (R_ini - a_ini);
                        % after x point desapear
                        z0dinput.geo.R(k) = z0dinput.geo.R(k) - gap_wall + 1e-2;
                    end                   
                    %s
                    sepa_option.a = z0dinput.geo.a(k);
                    sepa_option.ra = z0dinput.geo.R(k);
                    z0d1t.geo.a = sepa_option.a;
                    z0d1t.geo.R = sepa_option.ra;
                    z0d1t.geo.z0 =z0dinput.geo.z0(k);
                    rep = z0separatrix(z0d1t,sepa_option,0);
                    z0dinput.geo.K(k) = rep.geo.K;
                    z0dinput.geo.d(k) = rep.geo.d;
                    z0dinput.geo.R(k) = rep.geo.R;
                    z0dinput.geo.a(k) = rep.geo.a;
                    z0dinput.exp0d.Rsepa(k,:) = rep.exp0d.Rsepa(1,:) - (max(rep.exp0d.Rsepa(1,:)) + min(rep.exp0d.Rsepa(1,:))) ./ 2 + z0d1t.geo.R;
                    % kept xpoint position fixed
                    if z0dinput.cons.temps(k) <= sepa_option.toff
                            z0dinput.exp0d.Zsepa(k,:) = rep.exp0d.Zsepa(1,:) - min(rep.exp0d.Zsepa(1,:)) - z0d1t.geo.z0 + z_xpoint_ref;
                    else
                            z0dinput.exp0d.Zsepa(k,:) = rep.exp0d.Zsepa(1,:);
                    end
                    %figure(21);hold on
                    %plot(rwall,zwall,z0dinput.exp0d.Rsepa(k,:),z0dinput.exp0d.Zsepa(k,:) + z0dinput.geo.z0(k));
                    %drawnow
                end
                %z0dinput.geo.z0(k) = z0dinput.geo.z0(k) + 2.5e-2; % don't touch
                z0dinput.geo.z0(k) = z0dinput.geo.z0(k) + (max(z0dinput.exp0d.Zsepa(k,:)) + min(z0dinput.exp0d.Zsepa(k,:))) / 2 + 2.5e-2; % don't touch
                z0dinput.exp0d.Zsepa(k,:) = z0dinput.exp0d.Zsepa(k,:) - (max(z0dinput.exp0d.Zsepa(k,:)) + min(z0dinput.exp0d.Zsepa(k,:))) / 2;
%                 disp(nb)
%                 figure(21);clf
%                 plot(rwall,zwall,z0dinput.exp0d.Rsepa(k,:),z0dinput.exp0d.Zsepa(k,:) + z0dinput.geo.z0(k));
%                 drawnow
            else
                z0dinput.geo.z0(k) + (max(z0dinput.exp0d.Zsepa(k,:)) + min(z0dinput.exp0d.Zsepa(k,:))) / 2 + 2.5e-2
                z0dinput.geo.z0(k) = z0dinput.geo.z0(k) + (max(z0dinput.exp0d.Zsepa(k,:)) + min(z0dinput.exp0d.Zsepa(k,:))) / 2 + 2.5e-2; % don't touch
                z0dinput.exp0d.Zsepa(k,:) = z0dinput.exp0d.Zsepa(k,:) - (max(z0dinput.exp0d.Zsepa(k,:)) + min(z0dinput.exp0d.Zsepa(k,:))) / 2;                
            end
            % time regularisation
            z0dinput.geo.d(k) = max(0,min(z0dinput.geo.d(k),z0dinput.geo.d(k - 1)));
            z0dinput.geo.K(k) = max(1,min(z0dinput.geo.K(k),z0dinput.geo.K(k - 1)));
            z0dinput.geo.a(k) = min(z0dinput.geo.a(k),z0dinput.geo.a(k - 1));
            z0dinput.geo.R(k) = min(z0dinput.geo.R(k),z0dinput.geo.R(k - 1));
        end
end

indqa = find(temps >= tdn)';
ipmem =  z0dinput.cons.ip;
qlim  = 3;
for k=indqa
            % adjust Ip to kept q95 constant if q95 < 2,7 ? -> better to put 3
            % use the full formula
            qa = 5 .* z0dinput.geo.a(k) .^ 2 .* rb0 ./ ( z0dinput.cons.ip(k) ./ 1e6) ./ z0dinput.geo.R(k) ^ 2 .* (1 + z0dinput.geo.K(k) .^ 2 .*  ...
                  (1 + 2 .* z0dinput.geo.d(k) .^ 2 - 1.2 .* z0dinput.geo.d(k) .^ 3) ./ 2) .* (1.17 - 0.65 .* z0dinput.geo.a(k) ./ z0dinput.geo.R(k)) ./  ...
                  (1 - (z0dinput.geo.a(k) ./ z0dinput.geo.R(k)) .^ 2 ) .^ 2;
	    if qa <= qlim
		 z0dinput.cons.ip(k:end)   = z0dinput.cons.ip(k:end) .* qa ./ qlim;
		 qlim = qlim + 0.01; 
	    end
            
end
for k=indqa
  z0dinput.cons.nbar(k) = sqrt(-1) .* imag(z0dinput.cons.nbar(k)) + min(real(z0dinput.cons.nbar(k)), ...
		                         z0dinput.cons.ip(k) / 1e6 ./ pi  ./ z0dinput.geo.a(k) .^ 2 .* 1e20);
end
%figure;plot(temps,ipmem,'b',temps,z0dinput.cons.ip,'r');


z0dinput.geo.b0 = rb0 ./ z0dinput.geo.R;


% limitation of Zeff
% evolution of Zeff following gaz density
ulh = 0.25;
fh  = zeros(size(temps));
fh(temps >= t_full_power) = 1;
negr     = (z0dinput.cons.ip ./ 1e6) ./ z0dinput.geo.a .^ 2 ./ pi .* 1e20;
K95 = z0dinput.geo.K .* (1 + 0.95 .^ 4 ) ./ 2 + 0.5 .* (1 - 0.95 .^4);
d95 = z0dinput.geo.d .* (0.95 .^ 2);
q95 = 5 .* z0dinput.geo.a .^ 2 .* z0dinput.geo.b0 ./ (ip./1e6) ./ z0dinput.geo.R .* (1 + K95 .^ 2 .*  ...
    (1 + 2 .* d95 .^ 2 - 1.2 .* d95 .^ 3) ./ 2) .* (1.17 - 0.65 .* z0dinput.geo.a ./ z0dinput.geo.R) ./  ...
    (1 - (z0dinput.geo.a./z0dinput.geo.R) .^ 2 ) .^ 2;
nbar_nat = min(negr,max(1e13, 1e20 .* (reference_simulation.rb0 ./ q95) .^ 0.6  .*  (ulh + (1 - ulh) .* fh) .* z0dinput.option.fnbar_nat));
nbar_star     = max(z0dinput.cons.nbar,nbar_nat);
zeff_max           =  min((zeff - 1) .* max(nbar_star)  ./ nbar_star + 1,max(z0dinput.option.zmax,z0dinput.option.zimp));
z0dinput.cons.zeff =  min(zeff_max,z0dinput.cons.zeff);
%figure(11);clf;plot(z0dinput.cons.temps,z0dinput.cons.zeff);drawnow
% print option data
disp('METIS parameters:')
z0dinput.option
tsnapshot = (1/4) .* t_flattop_plus  + (3/4) .* tend;

% remove time slice of x-point formation as it onduce a too large change in rho_max
z0dinput = remove_time_slice(z0dinput,t_after_xpoint - eps,t_after_xpoint + eps);

% maximum power used for each heating sources:
fprintf('max(P_nbi)  = %g MW\n',(max(real(z0dinput.cons.pnbi)) + max(imag(z0dinput.cons.pnbi)) + max(z0dinput.cons.picrh)) ./ 1e6);
% finally put all ECRH power in EC
z0dinput.cons.pecrh = z0dinput.cons.pecrh + z0dinput.cons.plh;
z0dinput.cons.plh(:) = 0;
fprintf('max(P_ecrh) = %g MW\n',max(z0dinput.cons.pecrh) ./ 1e6);

% set METIS main windows title
txt = 'Metis : Fast tokamak simulator';
txt = sprintf('%s (%s@%d)',txt,z0dinput.machine,z0dinput.shot);
setappdata(0,'METIS_INTERFACE_TITLE',txt);
if isappdata(0,'METIS_FILENAME');
    rmappdata(0,'METIS_FILENAME');
end


% computation of separatrix moment
function [R,a,z0,K,d] = sepamoment(option)
  % calcul des moments
  sepa  = z0dsepanew2(1,option);
  % centre pour angle d'integration
  rc = mean(sepa.R,2);
  zc = mean(sepa.Z,2);
  vc = ones(1,size(sepa.R,2));
  uc = unwrap(angle((sepa.R-rc*vc) + sqrt(-1) .* (sepa.Z  -zc*vc)));
  uc    = uc .* (uc >0) + (uc + 2*pi) .* (uc<= 0);
  uc(:,1)   = uc(:,end) + 2 .* pi;
  xu    = linspace(0,1,length(vc));
  %dudx  = pdederive(xu,uc,2,2,2,1);
  %dudx(:,1) = (dudx(:,1) +dudx(:,end)) ./ 2;
  %dudx(:,end) = dudx(:,1);
  dRdx  = pdederive(xu,sepa.R,2,2,2,1);
  dZdx  = pdederive(xu,sepa.Z,2,2,2,1);
  % calcul de R0 et Z0
  maskrmax  = (sepa.R == (max(sepa.R,[],2) * vc));
  % recalcul des parametres sur le vecteur final
  rmin  = min(sepa.R,[],2);
  rmax  = max(sepa.R,[],2);
  a = 0.5 .* (rmax - rmin);
  R = 0.5 .* (rmax + rmin);
  zmin  = min(sepa.Z,[],2);
  zmax  = max(sepa.Z,[],2);
  z0   = (zmax + zmin + sum(sepa.Z .* maskrmax,2) ./ sum(maskrmax,2)) ./ 3;
  K     = (abs(trapz(xu,sepa.Z .*  dRdx,2) ./ pi ./ a) + (zmax - zmin)) ./ 3 ./ a;
  rzmax = R;
  rzmin = R;
  for k = 1:size(sepa.Z,1)
      rzmax(k) = sepa.R(k,min(find(sepa.Z(k,:) == zmax(k))));
      rzmin(k) = sepa.R(k,min(find(sepa.Z(k,:) == zmin(k))));
  end
  uu   =  angle(rzmax - R + sqrt(-1) .* (zmax - z0));
  ul   =  angle(rzmin - R + sqrt(-1) .* (zmin - z0));
  tu   =  abs((acos((rzmax - R) ./ a) - acos(cos(uu))) ./ sin(uu));
  tl   =  abs((acos((rzmin - R) ./ a) - acos(cos(ul))) ./ sin(ul));
  tm   =  (tl + tu) ./ 2;
  d    =   abs(rzmax + rzmin -  2 .* R) ./ 2 ./ a;
  d    =  0.6 .* d + 0.4  .* sin(tm);



function flux_data_output_ = poloidal_flux(post,couplage)
        
        % z0plotflux.m
        NOPLUTFLUX_HELIOS = 1;
        z0plotflux;
        
        % create data structure
        liste_of_fields_ = who;
        for kkk_ = 1:length(liste_of_fields_)
            flux_data_output_.(liste_of_fields_{kkk_}) = eval(liste_of_fields_{kkk_});
        end
        
function peakdiv = compute_peak_div(post,angle,S,flux_exp)
            % reference  : Scaling of the tokamak near the scrape-off layer H-mode power width and implications for ITER,
            % T. Eich et al, Nucl. Fusion 53 (2013) 093031 (7pp); doi:10.1088/0029-5515/53/9/093031
            % plot des donnees du modele a 2 points
            zs      = post.zerod;
            option  = post.z0dinput.option;
            geo     = post.z0dinput.geo;
            cons    = post.z0dinput.cons;
            profli  = post.profil0d;
            
            % constante physique (phys)
            phys.c           =   2.99792458e8;             % vitesse de la lumiere dans le vide (m/s)  (definition)
            phys.h           =   6.62606876e-34;           % constante de Planck (J*s) (+/- 0.0000052e-34)
            phys.e           =   1.602176462e-19;          % charge de l'electron (C)   (+/- 0.000000063e-19)
            phys.mu0         =   4*pi*1e-7;                % permeabilite du vide (H/m) (definition)
            phys.epsi0       =   1./phys.c.^2./phys.mu0;   % permitivite du vide (F/m)  (definition)
            phys.g           =   6.673e-11;                % constante de la gravitation (N*m^2/kg^2) (+/- 0.010e-11)
            phys.k           =   1.3806503e-23;            % constante de Boltzmann (J/K)  (+/- 0.0000024e-23)
            phys.alpha       =   7.297352533e-3 ;          % constante de structure fine (+/- 0.000000027e-3 )
            phys.me          =   9.10938188e-31;           % masse au repos de l'electron (kg) (+/- 0.00000079e-31)
            phys.mp          =   1.6726485e-27;            % masse au repos du proton (kg)
            phys.ua          =   1.66053873e-27;           % 1 unite atomique (kg) (+/- 1.00000013e-27)
            phys.avo         =   6.02214199e23;            % nombre d'avogadro (mol^-1) (+/- 0.00000047e23)
            phys.sigma       =   5.670400e-8;              % constante de stephan ( W*m^-2*K^-4) (+/- 0.000040e-8)
            phys.pam3        =   (4.41e-4 .* phys.avo);    % conversion d'un nombre de particules en en Pa.m^3
            
            % compatibilite
            if ~isfield(option,'yield_model')
                option.yield_model      = 'Javev';
            end
            
            % puissance conduite a la separatrice
            pl        = max(zs.pin ./ 100,zs.pin - zs.prad - zs.pbrem - zs.pcyclo - zs.pioniz - zs.pradsol);
            % fraction perdue en volume dans la sol par rayonnement:
            %fesol   = max(0,min(1, (zs.pradsol + max(0,1 - option.fprad) .* zs.prad) ./ max(1,pl)));
            switch option.sol_rad
                case 'coupled'
                    fesol   = max(0,min(1, (zs.pradsol + max(0,1 - option.fprad) .* zs.prad) ./ max(1,pl)));
                    pradsol = zs.pradsol + max(0,1 - option.fprad) .* zs.prad;
                otherwise
                    fesol   = max(0,min(1, zs.pradsol ./ max(1,pl)));
                    pradsol = zs.pradsol;
            end
            
            % these E. Tsitrone
            lclim = pi .* geo.R .* zs.qa;
            lcpol = pi .* geo.R;
            lcx = sqrt(zs.peri .^ 2  + (pi .* geo.R .* option.lcx .* zs.qa) .^ 2);
            switch option.configuration
                case 0
                    lc = lcpol;
                case 1
                    lc = lclim;
                case 2
                    lc  = zs.xpoint .* lcx + (~zs.xpoint) .* lcpol;
                case 3
                    lc  = zs.xpoint .* lcx + (~zs.xpoint) .* lclim;
                otherwise
                    lc  = lcx;
            end
            %lc  = zs.modeh .* lcx + (~zs.modeh) .* lclim;
            
            if isfield(zs,'dsol')
                dsol = zs.dsol;
            elseif option.sol_lscale  == 0
                dsol        = geo.a ./ 100;
            elseif option.sol_lscale  > 0
                dsol        = geo.a .* option.sol_lscale;
            else
                dsol        = - geo.R .* option.sol_lscale;
            end
            
            
            % flux //  (formula 5.64 et 5.75 Stangeby)
            x      = profli.xli;
            ve     =  ones(size(x));
            Raxea  = interp1(profli.temps,profli.Raxe,zs.temps,'pchip','extrap');
            Fa     = interp1(profli.temps,profli.fdia,zs.temps,'pchip','extrap');
            psi    = interp1(profli.temps,profli.psi,zs.temps,'pchip','extrap');
            rmx    = interp1(profli.temps,profli.rmx,zs.temps,'pchip','extrap');
            zeffp  = interp1(profli.temps,profli.zeff,zs.temps,'pchip','extrap');
            nzp    = interp1(profli.temps,profli.nzp,zs.temps,'pchip','extrap');
            nwp    = interp1(profli.temps,profli.nwp,zs.temps,'pchip','extrap');
            nhep   = interp1(profli.temps,profli.nhep,zs.temps,'pchip','extrap');
            n1p    = interp1(profli.temps,profli.n1p,zs.temps,'pchip','extrap');
            nep    = interp1(profli.temps,profli.nep,zs.temps,'pchip','extrap');
            Qe     = interp1(profli.temps,profli.qe(:,end),zs.temps,'pchip','extrap');
            Qi     = interp1(profli.temps,profli.qi(:,end),zs.temps,'pchip','extrap');
            rext         = Raxea + geo.a * x;
            btor         = Fa ./ rext;
            grho         = abs((rmx(:,end) * ve)./ max(eps,pdederive(x,rext,0,2,2,1)));
            grho(:,1)    = grho(:,2);
            bpol         = -pdederive(x,psi,0,2,2,1) ./ rext .* grho ./ (rmx(:,end) * ve);
            ut           = atan(abs(bpol(:,end) ./  btor(:,end)));
            % flux //  (formula 5.64 et 5.75 Stangeby)
            switch option.sol_model
                case '2_points';
                    % rien
                otherwise
                    warning('the 2 points model is not used in this simulation','2 points model');
                    option.sol_model = '2_points';
            end
            [tebord,nelim,telim,qpl_target,err,nb,indbad,fmom,qpl_rad_div,qpl_neutral_div,qpl_tot,pl,zeff_div,gamma,mach_target] = ...
                z0convergence_2points_dic(option,post.z0dinput.cons,post.z0dinput.geo,post.zerod,post.profil0d);
            Asol_para = 2 .* pi  .* Raxea(:,end) .* dsol .* sin(ut);
            % 50 % du rayonnement du divertor retourne sur les plaques.
            pref = (qpl_target  + 0.5 .* qpl_rad_div) .* Asol_para;
            
            maskx = ones(size(zs.temps));
            maskx(zs.xpoint == 0) = NaN;
            
            % estimation parametrique du la puissance deposee
            [sb,qpdep,fnorm] = z0div_power_dep(angle,S,flux_exp,dsol,pref,option.fR_target .* geo.R,max(geo.a ./ 2));
            peakdiv = max(qpdep,[],2);
            peakdiv(zs.xpoint == 0)  = NaN;
            
function z0dinput = remove_time_slice(z0dinput,tmin,tmax)
temps = z0dinput.cons.temps;
tempo_nova = z0dinput.cons.temps((z0dinput.cons.temps < tmin) | (z0dinput.cons.temps > tmax));
% but time between timin and tmax must be removed at the end
cutting    = 1;

indplus = find(tempo_nova > max(temps));
  
%
% interpolation des donnees des structures
%
% consignes
noms = fieldnames(z0dinput.cons);
for k=1:length(noms)
	switch noms{k}
	case 'temps'
		z0dinput.cons.temps = tempo_nova;
        if cutting == 1
            z0dinput.cons.temps(z0dinput.cons.temps >= tmax) = z0dinput.cons.temps(z0dinput.cons.temps >= tmax) - tmax + tmin;
        end
	otherwise
		vlimmin = max(eps,0.1 .* min(z0dinput.cons.(noms{k})));
		vout    = z0dinput.cons.(noms{k})(end);
		z0dinput.cons.(noms{k}) = interp1(temps,z0dinput.cons.(noms{k}),tempo_nova,'linear','extrap');
		switch noms{k}
		case 'flux'
			% rien
		otherwise
			z0dinput.cons.(noms{k}) = max(z0dinput.cons.(noms{k}),vlimmin);
		end
		z0dinput.cons.(noms{k})(indplus:end) = vout;
	end
end
% geometrie
noms = fieldnames(z0dinput.geo);
for k=1:length(noms)
	switch noms{k}
	case 'temps'
		z0dinput.geo.temps = tempo_nova;
        if cutting == 1
            z0dinput.geo.temps(z0dinput.geo.temps >= tmax) = z0dinput.geo.temps(z0dinput.geo.temps >= tmax) - tmax + tmin;
        end
   otherwise
        if ~isempty(z0dinput.geo.(noms{k}))
            vlimmin = max(eps,0.1 .* min(z0dinput.geo.(noms{k})));
            vout    = z0dinput.geo.(noms{k})(end);
            z0dinput.geo.(noms{k}) = interp1(temps,z0dinput.geo.(noms{k}),tempo_nova,'linear','extrap');
            switch noms{k}
                case 'z0'
                    % nothing to do
                otherwise
                z0dinput.geo.(noms{k}) = max(z0dinput.geo.(noms{k}),vlimmin);
            end
            z0dinput.geo.(noms{k})(indplus:end) = vout;
        end
	end
end
% experience
noms = fieldnames(z0dinput.exp0d);
for k=1:length(noms)
	switch noms{k}
	case 'temps'
		z0dinput.exp0d.temps = tempo_nova;
        if cutting == 1
            z0dinput.exp0d.temps(z0dinput.exp0d.temps >= tmax) = z0dinput.exp0d.temps(z0dinput.exp0d.temps >= tmax) - tmax + tmin;
        end
	otherwise
		if size(z0dinput.exp0d.(noms{k}),1) == length(temps)
			warning off
			z0dinput.exp0d.(noms{k}) = interp1(temps,z0dinput.exp0d.(noms{k}),tempo_nova,'nearest','extrap');
			warning on
		end
	end
end
